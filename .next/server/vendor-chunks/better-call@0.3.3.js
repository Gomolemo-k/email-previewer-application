"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/better-call@0.3.3";
exports.ids = ["vendor-chunks/better-call@0.3.3"];
exports.modules = {

/***/ "(action-browser)/./node_modules/.pnpm/better-call@0.3.3/node_modules/better-call/dist/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/better-call@0.3.3/node_modules/better-call/dist/index.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIError: () => (/* binding */ APIError),\n/* harmony export */   createEndpoint: () => (/* binding */ createEndpoint),\n/* harmony export */   createEndpointCreator: () => (/* binding */ createEndpointCreator),\n/* harmony export */   createMiddleware: () => (/* binding */ createMiddleware),\n/* harmony export */   createMiddlewareCreator: () => (/* binding */ createMiddlewareCreator),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   getBody: () => (/* binding */ getBody),\n/* harmony export */   getCookie: () => (/* binding */ getCookie),\n/* harmony export */   getRequest: () => (/* binding */ getRequest),\n/* harmony export */   getSignedCookie: () => (/* binding */ getSignedCookie),\n/* harmony export */   json: () => (/* binding */ json),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseSigned: () => (/* binding */ parseSigned),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   serializeSigned: () => (/* binding */ serializeSigned),\n/* harmony export */   setCookie: () => (/* binding */ setCookie),\n/* harmony export */   setResponse: () => (/* binding */ setResponse),\n/* harmony export */   setSignedCookie: () => (/* binding */ setSignedCookie),\n/* harmony export */   shouldSerialize: () => (/* binding */ shouldSerialize),\n/* harmony export */   signCookieValue: () => (/* binding */ signCookieValue),\n/* harmony export */   statusCode: () => (/* binding */ statusCode),\n/* harmony export */   toNodeHandler: () => (/* binding */ toNodeHandler)\n/* harmony export */ });\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod */ \"(action-browser)/./node_modules/.pnpm/zod@3.25.64/node_modules/zod/dist/esm/index.js\");\n/* harmony import */ var uncrypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uncrypto */ \"(action-browser)/./node_modules/.pnpm/uncrypto@0.1.3/node_modules/uncrypto/dist/crypto.node.mjs\");\n/* harmony import */ var rou3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rou3 */ \"(action-browser)/./node_modules/.pnpm/rou3@0.5.1/node_modules/rou3/dist/index.mjs\");\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// node_modules/set-cookie-parser/lib/set-cookie.js\nvar require_set_cookie = __commonJS({\n  \"node_modules/set-cookie-parser/lib/set-cookie.js\"(exports, module) {\n    \"use strict\";\n    var defaultParseOptions = {\n      decodeValues: true,\n      map: false,\n      silent: false\n    };\n    function isNonEmptyString(str) {\n      return typeof str === \"string\" && !!str.trim();\n    }\n    function parseString(setCookieValue, options) {\n      var parts = setCookieValue.split(\";\").filter(isNonEmptyString);\n      var nameValuePairStr = parts.shift();\n      var parsed = parseNameValuePair(nameValuePairStr);\n      var name = parsed.name;\n      var value = parsed.value;\n      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;\n      try {\n        value = options.decodeValues ? decodeURIComponent(value) : value;\n      } catch (e) {\n        console.error(\n          \"set-cookie-parser encountered an error while decoding a cookie with value '\" + value + \"'. Set options.decodeValues to false to disable this feature.\",\n          e\n        );\n      }\n      var cookie = {\n        name,\n        value\n      };\n      parts.forEach(function(part) {\n        var sides = part.split(\"=\");\n        var key = sides.shift().trimLeft().toLowerCase();\n        var value2 = sides.join(\"=\");\n        if (key === \"expires\") {\n          cookie.expires = new Date(value2);\n        } else if (key === \"max-age\") {\n          cookie.maxAge = parseInt(value2, 10);\n        } else if (key === \"secure\") {\n          cookie.secure = true;\n        } else if (key === \"httponly\") {\n          cookie.httpOnly = true;\n        } else if (key === \"samesite\") {\n          cookie.sameSite = value2;\n        } else if (key === \"partitioned\") {\n          cookie.partitioned = true;\n        } else {\n          cookie[key] = value2;\n        }\n      });\n      return cookie;\n    }\n    function parseNameValuePair(nameValuePairStr) {\n      var name = \"\";\n      var value = \"\";\n      var nameValueArr = nameValuePairStr.split(\"=\");\n      if (nameValueArr.length > 1) {\n        name = nameValueArr.shift();\n        value = nameValueArr.join(\"=\");\n      } else {\n        value = nameValuePairStr;\n      }\n      return { name, value };\n    }\n    function parse2(input, options) {\n      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;\n      if (!input) {\n        if (!options.map) {\n          return [];\n        } else {\n          return {};\n        }\n      }\n      if (input.headers) {\n        if (typeof input.headers.getSetCookie === \"function\") {\n          input = input.headers.getSetCookie();\n        } else if (input.headers[\"set-cookie\"]) {\n          input = input.headers[\"set-cookie\"];\n        } else {\n          var sch = input.headers[Object.keys(input.headers).find(function(key) {\n            return key.toLowerCase() === \"set-cookie\";\n          })];\n          if (!sch && input.headers.cookie && !options.silent) {\n            console.warn(\n              \"Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.\"\n            );\n          }\n          input = sch;\n        }\n      }\n      if (!Array.isArray(input)) {\n        input = [input];\n      }\n      if (!options.map) {\n        return input.filter(isNonEmptyString).map(function(str) {\n          return parseString(str, options);\n        });\n      } else {\n        var cookies = {};\n        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {\n          var cookie = parseString(str, options);\n          cookies2[cookie.name] = cookie;\n          return cookies2;\n        }, cookies);\n      }\n    }\n    function splitCookiesString2(cookiesString) {\n      if (Array.isArray(cookiesString)) {\n        return cookiesString;\n      }\n      if (typeof cookiesString !== \"string\") {\n        return [];\n      }\n      var cookiesStrings = [];\n      var pos = 0;\n      var start;\n      var ch;\n      var lastComma;\n      var nextStart;\n      var cookiesSeparatorFound;\n      function skipWhitespace() {\n        while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n          pos += 1;\n        }\n        return pos < cookiesString.length;\n      }\n      function notSpecialChar() {\n        ch = cookiesString.charAt(pos);\n        return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n      }\n      while (pos < cookiesString.length) {\n        start = pos;\n        cookiesSeparatorFound = false;\n        while (skipWhitespace()) {\n          ch = cookiesString.charAt(pos);\n          if (ch === \",\") {\n            lastComma = pos;\n            pos += 1;\n            skipWhitespace();\n            nextStart = pos;\n            while (pos < cookiesString.length && notSpecialChar()) {\n              pos += 1;\n            }\n            if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n              cookiesSeparatorFound = true;\n              pos = nextStart;\n              cookiesStrings.push(cookiesString.substring(start, lastComma));\n              start = pos;\n            } else {\n              pos = lastComma + 1;\n            }\n          } else {\n            pos += 1;\n          }\n        }\n        if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n        }\n      }\n      return cookiesStrings;\n    }\n    module.exports = parse2;\n    module.exports.parse = parse2;\n    module.exports.parseString = parseString;\n    module.exports.splitCookiesString = splitCookiesString2;\n  }\n});\n\n// src/endpoint.ts\n\n\n// src/error.ts\nvar APIError = class extends Error {\n  constructor(status, body, headers) {\n    super(`API Error: ${status} ${body?.message ?? \"\"}`, {\n      cause: body\n    });\n    __publicField(this, \"status\");\n    __publicField(this, \"headers\");\n    __publicField(this, \"body\");\n    this.status = status;\n    this.body = body ?? {};\n    this.body.code = body?.message ? body.message.toUpperCase().replace(/ /g, \"_\").replace(/[^A-Z0-9_]/g, \"\") : status;\n    this.stack = \"\";\n    this.headers = headers ?? new Headers();\n    if (!this.headers.has(\"Content-Type\")) {\n      this.headers.set(\"Content-Type\", \"application/json\");\n    }\n    this.name = \"BetterCallAPIError\";\n  }\n};\n\n// src/helper.ts\nvar json = (body, option) => {\n  return {\n    response: {\n      body: option?.body ?? body,\n      status: option?.status ?? 200,\n      statusText: option?.statusText ?? \"OK\",\n      headers: option?.headers\n    },\n    body,\n    _flag: \"json\"\n  };\n};\n\n// src/cookie.ts\n\nvar algorithm = { name: \"HMAC\", hash: \"SHA-256\" };\nvar getCryptoKey = async (secret) => {\n  const secretBuf = typeof secret === \"string\" ? new TextEncoder().encode(secret) : secret;\n  return await uncrypto__WEBPACK_IMPORTED_MODULE_1__.subtle.importKey(\"raw\", secretBuf, algorithm, false, [\"sign\", \"verify\"]);\n};\nvar makeSignature = async (value, secret) => {\n  const key = await getCryptoKey(secret);\n  const signature = await uncrypto__WEBPACK_IMPORTED_MODULE_1__.subtle.sign(algorithm.name, key, new TextEncoder().encode(value));\n  return btoa(String.fromCharCode(...new Uint8Array(signature)));\n};\nvar verifySignature = async (base64Signature, value, secret) => {\n  try {\n    const signatureBinStr = atob(base64Signature);\n    const signature = new Uint8Array(signatureBinStr.length);\n    for (let i = 0, len = signatureBinStr.length; i < len; i++) {\n      signature[i] = signatureBinStr.charCodeAt(i);\n    }\n    return await uncrypto__WEBPACK_IMPORTED_MODULE_1__.subtle.verify(algorithm, secret, signature, new TextEncoder().encode(value));\n  } catch (e) {\n    return false;\n  }\n};\nvar validCookieNameRegEx = /^[\\w!#$%&'*.^`|~+-]+$/;\nvar validCookieValueRegEx = /^[ !#-:<-[\\]-~]*$/;\nvar parse = (cookie, name) => {\n  const pairs = cookie.trim().split(\";\");\n  return pairs.reduce((parsedCookie, pairStr) => {\n    pairStr = pairStr.trim();\n    const valueStartPos = pairStr.indexOf(\"=\");\n    if (valueStartPos === -1) {\n      return parsedCookie;\n    }\n    const cookieName = pairStr.substring(0, valueStartPos).trim();\n    if (name && name !== cookieName || !validCookieNameRegEx.test(cookieName)) {\n      return parsedCookie;\n    }\n    let cookieValue = pairStr.substring(valueStartPos + 1).trim();\n    if (cookieValue.startsWith('\"') && cookieValue.endsWith('\"')) {\n      cookieValue = cookieValue.slice(1, -1);\n    }\n    if (validCookieValueRegEx.test(cookieValue)) {\n      parsedCookie[cookieName] = decodeURIComponent(cookieValue);\n    }\n    return parsedCookie;\n  }, {});\n};\nvar parseSigned = async (cookie, secret, name) => {\n  const parsedCookie = {};\n  const secretKey = await getCryptoKey(secret);\n  for (const [key, value] of Object.entries(parse(cookie, name))) {\n    const signatureStartPos = value.lastIndexOf(\".\");\n    if (signatureStartPos < 1) {\n      continue;\n    }\n    const signedValue = value.substring(0, signatureStartPos);\n    const signature = value.substring(signatureStartPos + 1);\n    if (signature.length !== 44 || !signature.endsWith(\"=\")) {\n      continue;\n    }\n    const isVerified = await verifySignature(signature, signedValue, secretKey);\n    parsedCookie[key] = isVerified ? signedValue : false;\n  }\n  return parsedCookie;\n};\nvar _serialize = (name, value, opt = {}) => {\n  let cookie = `${name}=${value}`;\n  if (name.startsWith(\"__Secure-\") && !opt.secure) {\n    opt.secure = true;\n  }\n  if (name.startsWith(\"__Host-\")) {\n    if (!opt.secure) {\n      opt.secure = true;\n    }\n    if (opt.path !== \"/\") {\n      opt.path = \"/\";\n    }\n    if (opt.domain) {\n      opt.domain = void 0;\n    }\n  }\n  if (opt && typeof opt.maxAge === \"number\" && opt.maxAge >= 0) {\n    if (opt.maxAge > 3456e4) {\n      throw new Error(\n        \"Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.\"\n      );\n    }\n    cookie += `; Max-Age=${Math.floor(opt.maxAge)}`;\n  }\n  if (opt.domain && opt.prefix !== \"host\") {\n    cookie += `; Domain=${opt.domain}`;\n  }\n  if (opt.path) {\n    cookie += `; Path=${opt.path}`;\n  }\n  if (opt.expires) {\n    if (opt.expires.getTime() - Date.now() > 3456e7) {\n      throw new Error(\n        \"Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.\"\n      );\n    }\n    cookie += `; Expires=${opt.expires.toUTCString()}`;\n  }\n  if (opt.httpOnly) {\n    cookie += \"; HttpOnly\";\n  }\n  if (opt.secure) {\n    cookie += \"; Secure\";\n  }\n  if (opt.sameSite) {\n    cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;\n  }\n  if (opt.partitioned) {\n    if (!opt.secure) {\n      throw new Error(\"Partitioned Cookie must have Secure attributes\");\n    }\n    cookie += \"; Partitioned\";\n  }\n  return cookie;\n};\nvar serialize = (name, value, opt) => {\n  value = encodeURIComponent(value);\n  return _serialize(name, value, opt);\n};\nvar serializeSigned = async (name, value, secret, opt = {}) => {\n  const signature = await makeSignature(value, secret);\n  value = `${value}.${signature}`;\n  value = encodeURIComponent(value);\n  return _serialize(name, value, opt);\n};\nvar signCookieValue = async (value, secret) => {\n  const signature = await makeSignature(value, secret);\n  value = `${value}.${signature}`;\n  value = encodeURIComponent(value);\n  return value;\n};\n\n// src/cookie-utils.ts\nvar getCookie = (cookie, key, prefix) => {\n  if (!cookie) {\n    return void 0;\n  }\n  let finalKey = key;\n  if (prefix) {\n    if (prefix === \"secure\") {\n      finalKey = \"__Secure-\" + key;\n    } else if (prefix === \"host\") {\n      finalKey = \"__Host-\" + key;\n    } else {\n      return void 0;\n    }\n  }\n  const obj = parse(cookie, finalKey);\n  return obj[finalKey];\n};\nvar setCookie = (header, name, value, opt) => {\n  const existingCookies = header.get(\"Set-Cookie\");\n  if (existingCookies) {\n    const cookies = existingCookies.split(\", \");\n    const updatedCookies = cookies.filter((cookie2) => !cookie2.startsWith(`${name}=`));\n    header.delete(\"Set-Cookie\");\n    updatedCookies.forEach((cookie2) => header.append(\"Set-Cookie\", cookie2));\n  }\n  let cookie;\n  if (opt?.prefix === \"secure\") {\n    cookie = serialize(\"__Secure-\" + name, value, { path: \"/\", ...opt, secure: true });\n  } else if (opt?.prefix === \"host\") {\n    cookie = serialize(\"__Host-\" + name, value, {\n      ...opt,\n      path: \"/\",\n      secure: true,\n      domain: void 0\n    });\n  } else {\n    cookie = serialize(name, value, { path: \"/\", ...opt });\n  }\n  header.append(\"Set-Cookie\", cookie);\n};\nvar setSignedCookie = async (header, name, value, secret, opt) => {\n  let cookie;\n  if (opt?.prefix === \"secure\") {\n    cookie = await serializeSigned(\"__Secure-\" + name, value, secret, {\n      path: \"/\",\n      ...opt,\n      secure: true\n    });\n  } else if (opt?.prefix === \"host\") {\n    cookie = await serializeSigned(\"__Host-\" + name, value, secret, {\n      ...opt,\n      path: \"/\",\n      secure: true,\n      domain: void 0\n    });\n  } else {\n    cookie = await serializeSigned(name, value, secret, { path: \"/\", ...opt });\n  }\n  header.append(\"Set-Cookie\", cookie);\n};\nvar getSignedCookie = async (header, secret, key, prefix) => {\n  const cookie = header.get(\"cookie\");\n  if (!cookie) {\n    return void 0;\n  }\n  let finalKey = key;\n  if (prefix) {\n    if (prefix === \"secure\") {\n      finalKey = \"__Secure-\" + key;\n    } else if (prefix === \"host\") {\n      finalKey = \"__Host-\" + key;\n    }\n  }\n  const obj = await parseSigned(cookie, secret, finalKey);\n  return obj[finalKey];\n};\n\n// src/endpoint.ts\nfunction createEndpointCreator(opts) {\n  return (path, options, handler) => {\n    return createEndpoint(\n      path,\n      {\n        ...options,\n        use: [...options?.use || [], ...opts?.use || []]\n      },\n      handler\n    );\n  };\n}\nfunction createEndpoint(path, options, handler) {\n  let responseHeader = new Headers();\n  const handle = async (...ctx) => {\n    let internalCtx = {\n      setHeader(key, value) {\n        responseHeader.set(key, value);\n      },\n      setCookie(key, value, options2) {\n        setCookie(responseHeader, key, value, options2);\n      },\n      getCookie(key, prefix) {\n        const header = ctx[0]?.headers;\n        const cookieH = header?.get(\"cookie\");\n        const cookie = getCookie(cookieH || \"\", key, prefix);\n        return cookie;\n      },\n      getSignedCookie(key, secret, prefix) {\n        const header = ctx[0]?.headers;\n        if (!header) {\n          throw new TypeError(\"Headers are required\");\n        }\n        const cookie = getSignedCookie(header, secret, key, prefix);\n        return cookie;\n      },\n      async setSignedCookie(key, value, secret, options2) {\n        await setSignedCookie(responseHeader, key, value, secret, options2);\n      },\n      redirect(url) {\n        responseHeader.set(\"Location\", url);\n        return new APIError(\"FOUND\");\n      },\n      json,\n      context: ctx[0]?.context || {},\n      _flag: ctx[0]?.asResponse ? \"router\" : ctx[0]?._flag,\n      responseHeader,\n      path,\n      ...ctx[0] || {}\n    };\n    if (options.use?.length) {\n      let middlewareContexts = {};\n      let middlewareBody = {};\n      for (const middleware of options.use) {\n        if (typeof middleware !== \"function\") {\n          console.warn(\"Middleware is not a function\", {\n            middleware\n          });\n          continue;\n        }\n        const res = await middleware(internalCtx);\n        if (res) {\n          const body = res.options?.body ? res.options.body.parse(internalCtx.body) : void 0;\n          middlewareContexts = {\n            ...middlewareContexts,\n            ...res\n          };\n          middlewareBody = {\n            ...middlewareBody,\n            ...body\n          };\n        }\n      }\n      internalCtx = {\n        ...internalCtx,\n        body: {\n          ...middlewareBody,\n          ...internalCtx.body\n        },\n        context: {\n          ...internalCtx.context || {},\n          ...middlewareContexts\n        }\n      };\n    }\n    try {\n      const body = options.body ? options.body.parse(internalCtx.body) : internalCtx.body;\n      internalCtx = {\n        ...internalCtx,\n        body: body ? {\n          ...body,\n          ...internalCtx.body\n        } : internalCtx.body\n      };\n      internalCtx.query = options.query ? options.query.parse(internalCtx.query) : internalCtx.query;\n    } catch (e) {\n      if (e instanceof zod__WEBPACK_IMPORTED_MODULE_0__.ZodError) {\n        throw new APIError(\"BAD_REQUEST\", {\n          message: e.message,\n          details: e.errors\n        });\n      }\n      throw e;\n    }\n    if (options.requireHeaders && !internalCtx.headers) {\n      throw new APIError(\"BAD_REQUEST\", {\n        message: \"Headers are required\"\n      });\n    }\n    if (options.requireRequest && !internalCtx.request) {\n      throw new APIError(\"BAD_REQUEST\", {\n        message: \"Request is required\"\n      });\n    }\n    if (internalCtx.request && !internalCtx.headers) {\n      internalCtx.headers = internalCtx.request.headers;\n    }\n    try {\n      let res = await handler(internalCtx);\n      let actualResponse = res;\n      if (res && typeof res === \"object\" && \"_flag\" in res) {\n        if (res._flag === \"json\" && internalCtx._flag === \"router\") {\n          const h = res.response.headers;\n          Object.keys(h || {}).forEach((key) => {\n            responseHeader.set(key, h[key]);\n          });\n          responseHeader.set(\"Content-Type\", \"application/json\");\n          actualResponse = new Response(JSON.stringify(res.response.body), {\n            status: res.response.status ?? 200,\n            statusText: res.response.statusText,\n            headers: responseHeader\n          });\n        } else {\n          actualResponse = res.body;\n        }\n      }\n      responseHeader = new Headers();\n      return actualResponse;\n    } catch (e) {\n      if (e instanceof APIError) {\n        responseHeader.set(\"Content-Type\", \"application/json\");\n        e.headers = responseHeader;\n        responseHeader = new Headers();\n        throw e;\n      }\n      throw e;\n    }\n  };\n  handle.path = path;\n  handle.options = options;\n  handle.method = options.method;\n  handle.headers = responseHeader;\n  return handle;\n}\n\n// src/router.ts\n\n\n// src/utils.ts\nasync function getBody(request) {\n  const contentType = request.headers.get(\"content-type\") || \"\";\n  if (!request.body) {\n    return void 0;\n  }\n  if (contentType.includes(\"application/json\")) {\n    return await request.json();\n  }\n  if (contentType.includes(\"application/x-www-form-urlencoded\")) {\n    const formData = await request.formData();\n    const result = {};\n    formData.forEach((value, key) => {\n      result[key] = value.toString();\n    });\n    return result;\n  }\n  if (contentType.includes(\"multipart/form-data\")) {\n    const formData = await request.formData();\n    const result = {};\n    formData.forEach((value, key) => {\n      result[key] = value;\n    });\n    return result;\n  }\n  if (contentType.includes(\"text/plain\")) {\n    return await request.text();\n  }\n  if (contentType.includes(\"application/octet-stream\")) {\n    return await request.arrayBuffer();\n  }\n  if (contentType.includes(\"application/pdf\") || contentType.includes(\"image/\") || contentType.includes(\"video/\")) {\n    const blob = await request.blob();\n    return blob;\n  }\n  if (contentType.includes(\"application/stream\") || request.body instanceof ReadableStream) {\n    return request.body;\n  }\n  return await request.text();\n}\nfunction shouldSerialize(body) {\n  return typeof body === \"object\" && body !== null && !(body instanceof Blob) && !(body instanceof FormData);\n}\nvar statusCode = {\n  OK: 200,\n  CREATED: 201,\n  ACCEPTED: 202,\n  NO_CONTENT: 204,\n  MULTIPLE_CHOICES: 300,\n  MOVED_PERMANENTLY: 301,\n  FOUND: 302,\n  SEE_OTHER: 303,\n  NOT_MODIFIED: 304,\n  TEMPORARY_REDIRECT: 307,\n  BAD_REQUEST: 400,\n  UNAUTHORIZED: 401,\n  PAYMENT_REQUIRED: 402,\n  FORBIDDEN: 403,\n  NOT_FOUND: 404,\n  METHOD_NOT_ALLOWED: 405,\n  NOT_ACCEPTABLE: 406,\n  PROXY_AUTHENTICATION_REQUIRED: 407,\n  REQUEST_TIMEOUT: 408,\n  CONFLICT: 409,\n  GONE: 410,\n  LENGTH_REQUIRED: 411,\n  PRECONDITION_FAILED: 412,\n  PAYLOAD_TOO_LARGE: 413,\n  URI_TOO_LONG: 414,\n  UNSUPPORTED_MEDIA_TYPE: 415,\n  RANGE_NOT_SATISFIABLE: 416,\n  EXPECTATION_FAILED: 417,\n  \"I'M_A_TEAPOT\": 418,\n  MISDIRECTED_REQUEST: 421,\n  UNPROCESSABLE_ENTITY: 422,\n  LOCKED: 423,\n  FAILED_DEPENDENCY: 424,\n  TOO_EARLY: 425,\n  UPGRADE_REQUIRED: 426,\n  PRECONDITION_REQUIRED: 428,\n  TOO_MANY_REQUESTS: 429,\n  REQUEST_HEADER_FIELDS_TOO_LARGE: 431,\n  UNAVAILABLE_FOR_LEGAL_REASONS: 451,\n  INTERNAL_SERVER_ERROR: 500,\n  NOT_IMPLEMENTED: 501,\n  BAD_GATEWAY: 502,\n  SERVICE_UNAVAILABLE: 503,\n  GATEWAY_TIMEOUT: 504,\n  HTTP_VERSION_NOT_SUPPORTED: 505,\n  VARIANT_ALSO_NEGOTIATES: 506,\n  INSUFFICIENT_STORAGE: 507,\n  LOOP_DETECTED: 508,\n  NOT_EXTENDED: 510,\n  NETWORK_AUTHENTICATION_REQUIRED: 511\n};\n\n// src/router.ts\nvar createRouter = (endpoints, config) => {\n  const _endpoints = Object.values(endpoints);\n  const router = (0,rou3__WEBPACK_IMPORTED_MODULE_2__.createRouter)();\n  for (const endpoint of _endpoints) {\n    if (endpoint.options.metadata?.SERVER_ONLY) continue;\n    if (Array.isArray(endpoint.options?.method)) {\n      for (const method of endpoint.options.method) {\n        (0,rou3__WEBPACK_IMPORTED_MODULE_2__.addRoute)(router, method, endpoint.path, endpoint);\n      }\n    } else {\n      (0,rou3__WEBPACK_IMPORTED_MODULE_2__.addRoute)(router, endpoint.options.method, endpoint.path, endpoint);\n    }\n  }\n  const middlewareRouter = (0,rou3__WEBPACK_IMPORTED_MODULE_2__.createRouter)();\n  for (const route of config?.routerMiddleware || []) {\n    (0,rou3__WEBPACK_IMPORTED_MODULE_2__.addRoute)(middlewareRouter, \"*\", route.path, route.middleware);\n  }\n  const handler = async (request) => {\n    const url = new URL(request.url);\n    let path = url.pathname;\n    if (config?.basePath) {\n      path = path.split(config.basePath)[1];\n    }\n    if (!path?.length) {\n      config?.onError?.(new APIError(\"NOT_FOUND\"));\n      console.warn(\n        `[better-call]: Make sure the URL has the basePath (${config?.basePath}).`\n      );\n      return new Response(null, {\n        status: 404,\n        statusText: \"Not Found\"\n      });\n    }\n    const method = request.method;\n    const route = (0,rou3__WEBPACK_IMPORTED_MODULE_2__.findRoute)(router, method, path);\n    const handler2 = route?.data;\n    const body = await getBody(request);\n    const headers = request.headers;\n    const query = Object.fromEntries(url.searchParams);\n    const routerMiddleware = (0,rou3__WEBPACK_IMPORTED_MODULE_2__.findAllRoutes)(middlewareRouter, \"*\", path);\n    if (!handler2) {\n      return new Response(null, {\n        status: 404,\n        statusText: \"Not Found\"\n      });\n    }\n    try {\n      let middlewareContext = {};\n      if (routerMiddleware?.length) {\n        for (const route2 of routerMiddleware) {\n          const middleware = route2.data;\n          const res = await middleware({\n            path,\n            method,\n            headers,\n            params: route2?.params,\n            request,\n            body,\n            query,\n            context: {\n              ...config?.extraContext\n            }\n          });\n          if (res instanceof Response) {\n            return res;\n          }\n          if (res?._flag === \"json\") {\n            return new Response(JSON.stringify(res), {\n              headers: res.headers\n            });\n          }\n          if (res) {\n            middlewareContext = {\n              ...res,\n              ...middlewareContext\n            };\n          }\n        }\n      }\n      const handlerRes = await handler2({\n        path,\n        method,\n        headers,\n        params: route?.params,\n        request,\n        body,\n        query,\n        _flag: \"router\",\n        context: {\n          ...middlewareContext,\n          ...config?.extraContext\n        }\n      });\n      if (handlerRes instanceof Response) {\n        return handlerRes;\n      }\n      const resBody = shouldSerialize(handlerRes) ? JSON.stringify(handlerRes) : handlerRes;\n      return new Response(resBody, {\n        headers: handler2.headers\n      });\n    } catch (e) {\n      if (config?.onError) {\n        const onErrorRes = await config.onError(e);\n        if (onErrorRes instanceof Response) {\n          return onErrorRes;\n        }\n      }\n      if (e instanceof APIError) {\n        return new Response(e.body ? JSON.stringify(e.body) : null, {\n          status: statusCode[e.status],\n          statusText: e.status,\n          headers: e.headers\n        });\n      }\n      if (config?.throwError) {\n        throw e;\n      }\n      return new Response(null, {\n        status: 500,\n        statusText: \"Internal Server Error\"\n      });\n    }\n  };\n  return {\n    handler: async (request) => {\n      const onReq = await config?.onRequest?.(request);\n      if (onReq instanceof Response) {\n        return onReq;\n      }\n      const req = onReq instanceof Request ? onReq : request;\n      const res = await handler(req);\n      const onRes = await config?.onResponse?.(res);\n      if (onRes instanceof Response) {\n        return onRes;\n      }\n      return res;\n    },\n    endpoints\n  };\n};\n\n// src/middleware.ts\nfunction createMiddleware(optionsOrHandler, handler) {\n  if (typeof optionsOrHandler === \"function\") {\n    return createEndpoint(\n      \"*\",\n      {\n        method: \"*\"\n      },\n      optionsOrHandler\n    );\n  }\n  if (!handler) {\n    throw new Error(\"Middleware handler is required\");\n  }\n  const endpoint = createEndpoint(\n    \"*\",\n    {\n      ...optionsOrHandler,\n      method: \"*\"\n    },\n    handler\n  );\n  return endpoint;\n}\nvar createMiddlewareCreator = (opts) => {\n  function fn(optionsOrHandler, handler) {\n    if (typeof optionsOrHandler === \"function\") {\n      return createEndpoint(\n        \"*\",\n        {\n          method: \"*\"\n        },\n        optionsOrHandler\n      );\n    }\n    if (!handler) {\n      throw new Error(\"Middleware handler is required\");\n    }\n    const endpoint = createEndpoint(\n      \"*\",\n      {\n        ...optionsOrHandler,\n        method: \"*\"\n      },\n      handler\n    );\n    return endpoint;\n  }\n  return fn;\n};\n\n// src/types.ts\n\n\n// src/adapter/request.ts\nvar set_cookie_parser = __toESM(require_set_cookie(), 1);\nfunction get_raw_body(req, body_size_limit) {\n  const h = req.headers;\n  if (!h[\"content-type\"]) return null;\n  const content_length = Number(h[\"content-length\"]);\n  if (req.httpVersionMajor === 1 && isNaN(content_length) && h[\"transfer-encoding\"] == null || content_length === 0) {\n    return null;\n  }\n  let length = content_length;\n  if (body_size_limit) {\n    if (!length) {\n      length = body_size_limit;\n    } else if (length > body_size_limit) {\n      throw Error(\n        `Received content-length of ${length}, but only accept up to ${body_size_limit} bytes.`\n      );\n    }\n  }\n  if (req.destroyed) {\n    const readable = new ReadableStream();\n    readable.cancel();\n    return readable;\n  }\n  let size = 0;\n  let cancelled = false;\n  return new ReadableStream({\n    start(controller) {\n      req.on(\"error\", (error) => {\n        cancelled = true;\n        controller.error(error);\n      });\n      req.on(\"end\", () => {\n        if (cancelled) return;\n        controller.close();\n      });\n      req.on(\"data\", (chunk) => {\n        if (cancelled) return;\n        size += chunk.length;\n        if (size > length) {\n          cancelled = true;\n          controller.error(\n            new Error(\n              `request body size exceeded ${content_length ? \"'content-length'\" : \"BODY_SIZE_LIMIT\"} of ${length}`\n            )\n          );\n          return;\n        }\n        controller.enqueue(chunk);\n        if (controller.desiredSize === null || controller.desiredSize <= 0) {\n          req.pause();\n        }\n      });\n    },\n    pull() {\n      req.resume();\n    },\n    cancel(reason) {\n      cancelled = true;\n      req.destroy(reason);\n    }\n  });\n}\nfunction getRequest({\n  request,\n  base,\n  bodySizeLimit\n}) {\n  return new Request(base + request.url, {\n    // @ts-expect-error\n    duplex: \"half\",\n    method: request.method,\n    body: get_raw_body(request, bodySizeLimit),\n    headers: request.headers\n  });\n}\nasync function setResponse(res, response) {\n  for (const [key, value] of response.headers) {\n    try {\n      res.setHeader(\n        key,\n        key === \"set-cookie\" ? set_cookie_parser.splitCookiesString(response.headers.get(key)) : value\n      );\n    } catch (error) {\n      res.getHeaderNames().forEach((name) => res.removeHeader(name));\n      res.writeHead(500).end(String(error));\n      return;\n    }\n  }\n  res.writeHead(response.status);\n  if (!response.body) {\n    res.end();\n    return;\n  }\n  if (response.body.locked) {\n    res.end(\n      \"Fatal error: Response body is locked. This can happen when the response was already read (for example through 'response.json()' or 'response.text()').\"\n    );\n    return;\n  }\n  const reader = response.body.getReader();\n  if (res.destroyed) {\n    reader.cancel();\n    return;\n  }\n  const cancel = (error) => {\n    res.off(\"close\", cancel);\n    res.off(\"error\", cancel);\n    reader.cancel(error).catch(() => {\n    });\n    if (error) res.destroy(error);\n  };\n  res.on(\"close\", cancel);\n  res.on(\"error\", cancel);\n  next();\n  async function next() {\n    try {\n      for (; ; ) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        if (!res.write(value)) {\n          res.once(\"drain\", next);\n          return;\n        }\n      }\n      res.end();\n    } catch (error) {\n      cancel(error instanceof Error ? error : new Error(String(error)));\n    }\n  }\n}\n\n// src/adapter/node.ts\nfunction toNodeHandler(handler) {\n  return async (req, res) => {\n    const protocol = req.headers[\"x-forwarded-proto\"] || (req.socket.encrypted ? \"https\" : \"http\");\n    const base = `${protocol}://${req.headers[\":authority\"] || req.headers.host}`;\n    const response = await handler(getRequest({ base, request: req }));\n    setResponse(res, response);\n  };\n}\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9iZXR0ZXItY2FsbEAwLjMuMy9ub2RlX21vZHVsZXMvYmV0dGVyLWNhbGwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDZEQUE2RDtBQUMzSTtBQUNBLDJEQUEyRCxhQUFhO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNEZBQTRGO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBLG1HQUFtRztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSw4QkFBOEI7QUFDdkc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLHdNQUF3TSxjQUFjO0FBQ3RO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QUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTLEtBQUssOENBQThDO0FBQ2hGLGdEQUFnRCxvQkFBb0I7QUFDcEU7QUFDQTtBQUNBO0FBd0JFO0FBQ0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9nb21vbGVtb2tnYXRpdHNvZS9wcm9qZWN0cy9lbWFpbC1wcmV2aWV3ZXItYXBwbGljYXRpb24vbm9kZV9tb2R1bGVzLy5wbnBtL2JldHRlci1jYWxsQDAuMy4zL25vZGVfbW9kdWxlcy9iZXR0ZXItY2FsbC9kaXN0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2NyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG52YXIgX19kZWZQcm9wID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIF9fZ2V0T3duUHJvcERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIF9fZ2V0T3duUHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXM7XG52YXIgX19nZXRQcm90b09mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xudmFyIF9faGFzT3duUHJvcCA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgX19kZWZOb3JtYWxQcm9wID0gKG9iaiwga2V5LCB2YWx1ZSkgPT4ga2V5IGluIG9iaiA/IF9fZGVmUHJvcChvYmosIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlLCB2YWx1ZSB9KSA6IG9ialtrZXldID0gdmFsdWU7XG52YXIgX19jb21tb25KUyA9IChjYiwgbW9kKSA9PiBmdW5jdGlvbiBfX3JlcXVpcmUoKSB7XG4gIHJldHVybiBtb2QgfHwgKDAsIGNiW19fZ2V0T3duUHJvcE5hbWVzKGNiKVswXV0pKChtb2QgPSB7IGV4cG9ydHM6IHt9IH0pLmV4cG9ydHMsIG1vZCksIG1vZC5leHBvcnRzO1xufTtcbnZhciBfX2NvcHlQcm9wcyA9ICh0bywgZnJvbSwgZXhjZXB0LCBkZXNjKSA9PiB7XG4gIGlmIChmcm9tICYmIHR5cGVvZiBmcm9tID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBmcm9tID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBmb3IgKGxldCBrZXkgb2YgX19nZXRPd25Qcm9wTmFtZXMoZnJvbSkpXG4gICAgICBpZiAoIV9faGFzT3duUHJvcC5jYWxsKHRvLCBrZXkpICYmIGtleSAhPT0gZXhjZXB0KVxuICAgICAgICBfX2RlZlByb3AodG8sIGtleSwgeyBnZXQ6ICgpID0+IGZyb21ba2V5XSwgZW51bWVyYWJsZTogIShkZXNjID0gX19nZXRPd25Qcm9wRGVzYyhmcm9tLCBrZXkpKSB8fCBkZXNjLmVudW1lcmFibGUgfSk7XG4gIH1cbiAgcmV0dXJuIHRvO1xufTtcbnZhciBfX3RvRVNNID0gKG1vZCwgaXNOb2RlTW9kZSwgdGFyZ2V0KSA9PiAodGFyZ2V0ID0gbW9kICE9IG51bGwgPyBfX2NyZWF0ZShfX2dldFByb3RvT2YobW9kKSkgOiB7fSwgX19jb3B5UHJvcHMoXG4gIC8vIElmIHRoZSBpbXBvcnRlciBpcyBpbiBub2RlIGNvbXBhdGliaWxpdHkgbW9kZSBvciB0aGlzIGlzIG5vdCBhbiBFU01cbiAgLy8gZmlsZSB0aGF0IGhhcyBiZWVuIGNvbnZlcnRlZCB0byBhIENvbW1vbkpTIGZpbGUgdXNpbmcgYSBCYWJlbC1cbiAgLy8gY29tcGF0aWJsZSB0cmFuc2Zvcm0gKGkuZS4gXCJfX2VzTW9kdWxlXCIgaGFzIG5vdCBiZWVuIHNldCksIHRoZW4gc2V0XG4gIC8vIFwiZGVmYXVsdFwiIHRvIHRoZSBDb21tb25KUyBcIm1vZHVsZS5leHBvcnRzXCIgZm9yIG5vZGUgY29tcGF0aWJpbGl0eS5cbiAgaXNOb2RlTW9kZSB8fCAhbW9kIHx8ICFtb2QuX19lc01vZHVsZSA/IF9fZGVmUHJvcCh0YXJnZXQsIFwiZGVmYXVsdFwiLCB7IHZhbHVlOiBtb2QsIGVudW1lcmFibGU6IHRydWUgfSkgOiB0YXJnZXQsXG4gIG1vZFxuKSk7XG52YXIgX19wdWJsaWNGaWVsZCA9IChvYmosIGtleSwgdmFsdWUpID0+IF9fZGVmTm9ybWFsUHJvcChvYmosIHR5cGVvZiBrZXkgIT09IFwic3ltYm9sXCIgPyBrZXkgKyBcIlwiIDoga2V5LCB2YWx1ZSk7XG5cbi8vIG5vZGVfbW9kdWxlcy9zZXQtY29va2llLXBhcnNlci9saWIvc2V0LWNvb2tpZS5qc1xudmFyIHJlcXVpcmVfc2V0X2Nvb2tpZSA9IF9fY29tbW9uSlMoe1xuICBcIm5vZGVfbW9kdWxlcy9zZXQtY29va2llLXBhcnNlci9saWIvc2V0LWNvb2tpZS5qc1wiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBkZWZhdWx0UGFyc2VPcHRpb25zID0ge1xuICAgICAgZGVjb2RlVmFsdWVzOiB0cnVlLFxuICAgICAgbWFwOiBmYWxzZSxcbiAgICAgIHNpbGVudDogZmFsc2VcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGlzTm9uRW1wdHlTdHJpbmcoc3RyKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHN0ciA9PT0gXCJzdHJpbmdcIiAmJiAhIXN0ci50cmltKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlU3RyaW5nKHNldENvb2tpZVZhbHVlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcGFydHMgPSBzZXRDb29raWVWYWx1ZS5zcGxpdChcIjtcIikuZmlsdGVyKGlzTm9uRW1wdHlTdHJpbmcpO1xuICAgICAgdmFyIG5hbWVWYWx1ZVBhaXJTdHIgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgdmFyIHBhcnNlZCA9IHBhcnNlTmFtZVZhbHVlUGFpcihuYW1lVmFsdWVQYWlyU3RyKTtcbiAgICAgIHZhciBuYW1lID0gcGFyc2VkLm5hbWU7XG4gICAgICB2YXIgdmFsdWUgPSBwYXJzZWQudmFsdWU7XG4gICAgICBvcHRpb25zID0gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRQYXJzZU9wdGlvbnMsIG9wdGlvbnMpIDogZGVmYXVsdFBhcnNlT3B0aW9ucztcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhbHVlID0gb3B0aW9ucy5kZWNvZGVWYWx1ZXMgPyBkZWNvZGVVUklDb21wb25lbnQodmFsdWUpIDogdmFsdWU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgXCJzZXQtY29va2llLXBhcnNlciBlbmNvdW50ZXJlZCBhbiBlcnJvciB3aGlsZSBkZWNvZGluZyBhIGNvb2tpZSB3aXRoIHZhbHVlICdcIiArIHZhbHVlICsgXCInLiBTZXQgb3B0aW9ucy5kZWNvZGVWYWx1ZXMgdG8gZmFsc2UgdG8gZGlzYWJsZSB0aGlzIGZlYXR1cmUuXCIsXG4gICAgICAgICAgZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdmFyIGNvb2tpZSA9IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH07XG4gICAgICBwYXJ0cy5mb3JFYWNoKGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgICAgdmFyIHNpZGVzID0gcGFydC5zcGxpdChcIj1cIik7XG4gICAgICAgIHZhciBrZXkgPSBzaWRlcy5zaGlmdCgpLnRyaW1MZWZ0KCkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIHZhbHVlMiA9IHNpZGVzLmpvaW4oXCI9XCIpO1xuICAgICAgICBpZiAoa2V5ID09PSBcImV4cGlyZXNcIikge1xuICAgICAgICAgIGNvb2tpZS5leHBpcmVzID0gbmV3IERhdGUodmFsdWUyKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwibWF4LWFnZVwiKSB7XG4gICAgICAgICAgY29va2llLm1heEFnZSA9IHBhcnNlSW50KHZhbHVlMiwgMTApO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJzZWN1cmVcIikge1xuICAgICAgICAgIGNvb2tpZS5zZWN1cmUgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gXCJodHRwb25seVwiKSB7XG4gICAgICAgICAgY29va2llLmh0dHBPbmx5ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwic2FtZXNpdGVcIikge1xuICAgICAgICAgIGNvb2tpZS5zYW1lU2l0ZSA9IHZhbHVlMjtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwicGFydGl0aW9uZWRcIikge1xuICAgICAgICAgIGNvb2tpZS5wYXJ0aXRpb25lZCA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29va2llW2tleV0gPSB2YWx1ZTI7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGNvb2tpZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcGFyc2VOYW1lVmFsdWVQYWlyKG5hbWVWYWx1ZVBhaXJTdHIpIHtcbiAgICAgIHZhciBuYW1lID0gXCJcIjtcbiAgICAgIHZhciB2YWx1ZSA9IFwiXCI7XG4gICAgICB2YXIgbmFtZVZhbHVlQXJyID0gbmFtZVZhbHVlUGFpclN0ci5zcGxpdChcIj1cIik7XG4gICAgICBpZiAobmFtZVZhbHVlQXJyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgbmFtZSA9IG5hbWVWYWx1ZUFyci5zaGlmdCgpO1xuICAgICAgICB2YWx1ZSA9IG5hbWVWYWx1ZUFyci5qb2luKFwiPVwiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gbmFtZVZhbHVlUGFpclN0cjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IG5hbWUsIHZhbHVlIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlMihpbnB1dCwgb3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFyc2VPcHRpb25zLCBvcHRpb25zKSA6IGRlZmF1bHRQYXJzZU9wdGlvbnM7XG4gICAgICBpZiAoIWlucHV0KSB7XG4gICAgICAgIGlmICghb3B0aW9ucy5tYXApIHtcbiAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaW5wdXQuaGVhZGVycykge1xuICAgICAgICBpZiAodHlwZW9mIGlucHV0LmhlYWRlcnMuZ2V0U2V0Q29va2llID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBpbnB1dCA9IGlucHV0LmhlYWRlcnMuZ2V0U2V0Q29va2llKCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5wdXQuaGVhZGVyc1tcInNldC1jb29raWVcIl0pIHtcbiAgICAgICAgICBpbnB1dCA9IGlucHV0LmhlYWRlcnNbXCJzZXQtY29va2llXCJdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzY2ggPSBpbnB1dC5oZWFkZXJzW09iamVjdC5rZXlzKGlucHV0LmhlYWRlcnMpLmZpbmQoZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4ga2V5LnRvTG93ZXJDYXNlKCkgPT09IFwic2V0LWNvb2tpZVwiO1xuICAgICAgICAgIH0pXTtcbiAgICAgICAgICBpZiAoIXNjaCAmJiBpbnB1dC5oZWFkZXJzLmNvb2tpZSAmJiAhb3B0aW9ucy5zaWxlbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgXCJXYXJuaW5nOiBzZXQtY29va2llLXBhcnNlciBhcHBlYXJzIHRvIGhhdmUgYmVlbiBjYWxsZWQgb24gYSByZXF1ZXN0IG9iamVjdC4gSXQgaXMgZGVzaWduZWQgdG8gcGFyc2UgU2V0LUNvb2tpZSBoZWFkZXJzIGZyb20gcmVzcG9uc2VzLCBub3QgQ29va2llIGhlYWRlcnMgZnJvbSByZXF1ZXN0cy4gU2V0IHRoZSBvcHRpb24ge3NpbGVudDogdHJ1ZX0gdG8gc3VwcHJlc3MgdGhpcyB3YXJuaW5nLlwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpbnB1dCA9IHNjaDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuICAgICAgICBpbnB1dCA9IFtpbnB1dF07XG4gICAgICB9XG4gICAgICBpZiAoIW9wdGlvbnMubWFwKSB7XG4gICAgICAgIHJldHVybiBpbnB1dC5maWx0ZXIoaXNOb25FbXB0eVN0cmluZykubWFwKGZ1bmN0aW9uKHN0cikge1xuICAgICAgICAgIHJldHVybiBwYXJzZVN0cmluZyhzdHIsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjb29raWVzID0ge307XG4gICAgICAgIHJldHVybiBpbnB1dC5maWx0ZXIoaXNOb25FbXB0eVN0cmluZykucmVkdWNlKGZ1bmN0aW9uKGNvb2tpZXMyLCBzdHIpIHtcbiAgICAgICAgICB2YXIgY29va2llID0gcGFyc2VTdHJpbmcoc3RyLCBvcHRpb25zKTtcbiAgICAgICAgICBjb29raWVzMltjb29raWUubmFtZV0gPSBjb29raWU7XG4gICAgICAgICAgcmV0dXJuIGNvb2tpZXMyO1xuICAgICAgICB9LCBjb29raWVzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3BsaXRDb29raWVzU3RyaW5nMihjb29raWVzU3RyaW5nKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjb29raWVzU3RyaW5nKSkge1xuICAgICAgICByZXR1cm4gY29va2llc1N0cmluZztcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY29va2llc1N0cmluZyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgY29va2llc1N0cmluZ3MgPSBbXTtcbiAgICAgIHZhciBwb3MgPSAwO1xuICAgICAgdmFyIHN0YXJ0O1xuICAgICAgdmFyIGNoO1xuICAgICAgdmFyIGxhc3RDb21tYTtcbiAgICAgIHZhciBuZXh0U3RhcnQ7XG4gICAgICB2YXIgY29va2llc1NlcGFyYXRvckZvdW5kO1xuICAgICAgZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UoKSB7XG4gICAgICAgIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiAvXFxzLy50ZXN0KGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbm90U3BlY2lhbENoYXIoKSB7XG4gICAgICAgIGNoID0gY29va2llc1N0cmluZy5jaGFyQXQocG9zKTtcbiAgICAgICAgcmV0dXJuIGNoICE9PSBcIj1cIiAmJiBjaCAhPT0gXCI7XCIgJiYgY2ggIT09IFwiLFwiO1xuICAgICAgfVxuICAgICAgd2hpbGUgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgIHN0YXJ0ID0gcG9zO1xuICAgICAgICBjb29raWVzU2VwYXJhdG9yRm91bmQgPSBmYWxzZTtcbiAgICAgICAgd2hpbGUgKHNraXBXaGl0ZXNwYWNlKCkpIHtcbiAgICAgICAgICBjaCA9IGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcyk7XG4gICAgICAgICAgaWYgKGNoID09PSBcIixcIikge1xuICAgICAgICAgICAgbGFzdENvbW1hID0gcG9zO1xuICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgICBza2lwV2hpdGVzcGFjZSgpO1xuICAgICAgICAgICAgbmV4dFN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgd2hpbGUgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIG5vdFNwZWNpYWxDaGFyKCkpIHtcbiAgICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgY29va2llc1N0cmluZy5jaGFyQXQocG9zKSA9PT0gXCI9XCIpIHtcbiAgICAgICAgICAgICAgY29va2llc1NlcGFyYXRvckZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcG9zID0gbmV4dFN0YXJ0O1xuICAgICAgICAgICAgICBjb29raWVzU3RyaW5ncy5wdXNoKGNvb2tpZXNTdHJpbmcuc3Vic3RyaW5nKHN0YXJ0LCBsYXN0Q29tbWEpKTtcbiAgICAgICAgICAgICAgc3RhcnQgPSBwb3M7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwb3MgPSBsYXN0Q29tbWEgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3MgKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb29raWVzU2VwYXJhdG9yRm91bmQgfHwgcG9zID49IGNvb2tpZXNTdHJpbmcubGVuZ3RoKSB7XG4gICAgICAgICAgY29va2llc1N0cmluZ3MucHVzaChjb29raWVzU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgY29va2llc1N0cmluZy5sZW5ndGgpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNvb2tpZXNTdHJpbmdzO1xuICAgIH1cbiAgICBtb2R1bGUuZXhwb3J0cyA9IHBhcnNlMjtcbiAgICBtb2R1bGUuZXhwb3J0cy5wYXJzZSA9IHBhcnNlMjtcbiAgICBtb2R1bGUuZXhwb3J0cy5wYXJzZVN0cmluZyA9IHBhcnNlU3RyaW5nO1xuICAgIG1vZHVsZS5leHBvcnRzLnNwbGl0Q29va2llc1N0cmluZyA9IHNwbGl0Q29va2llc1N0cmluZzI7XG4gIH1cbn0pO1xuXG4vLyBzcmMvZW5kcG9pbnQudHNcbmltcG9ydCB7IFpvZEVycm9yIH0gZnJvbSBcInpvZFwiO1xuXG4vLyBzcmMvZXJyb3IudHNcbnZhciBBUElFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihzdGF0dXMsIGJvZHksIGhlYWRlcnMpIHtcbiAgICBzdXBlcihgQVBJIEVycm9yOiAke3N0YXR1c30gJHtib2R5Py5tZXNzYWdlID8/IFwiXCJ9YCwge1xuICAgICAgY2F1c2U6IGJvZHlcbiAgICB9KTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwic3RhdHVzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJoZWFkZXJzXCIpO1xuICAgIF9fcHVibGljRmllbGQodGhpcywgXCJib2R5XCIpO1xuICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgIHRoaXMuYm9keSA9IGJvZHkgPz8ge307XG4gICAgdGhpcy5ib2R5LmNvZGUgPSBib2R5Py5tZXNzYWdlID8gYm9keS5tZXNzYWdlLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvIC9nLCBcIl9cIikucmVwbGFjZSgvW15BLVowLTlfXS9nLCBcIlwiKSA6IHN0YXR1cztcbiAgICB0aGlzLnN0YWNrID0gXCJcIjtcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzID8/IG5ldyBIZWFkZXJzKCk7XG4gICAgaWYgKCF0aGlzLmhlYWRlcnMuaGFzKFwiQ29udGVudC1UeXBlXCIpKSB7XG4gICAgICB0aGlzLmhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICB9XG4gICAgdGhpcy5uYW1lID0gXCJCZXR0ZXJDYWxsQVBJRXJyb3JcIjtcbiAgfVxufTtcblxuLy8gc3JjL2hlbHBlci50c1xudmFyIGpzb24gPSAoYm9keSwgb3B0aW9uKSA9PiB7XG4gIHJldHVybiB7XG4gICAgcmVzcG9uc2U6IHtcbiAgICAgIGJvZHk6IG9wdGlvbj8uYm9keSA/PyBib2R5LFxuICAgICAgc3RhdHVzOiBvcHRpb24/LnN0YXR1cyA/PyAyMDAsXG4gICAgICBzdGF0dXNUZXh0OiBvcHRpb24/LnN0YXR1c1RleHQgPz8gXCJPS1wiLFxuICAgICAgaGVhZGVyczogb3B0aW9uPy5oZWFkZXJzXG4gICAgfSxcbiAgICBib2R5LFxuICAgIF9mbGFnOiBcImpzb25cIlxuICB9O1xufTtcblxuLy8gc3JjL2Nvb2tpZS50c1xuaW1wb3J0IHsgc3VidGxlIH0gZnJvbSBcInVuY3J5cHRvXCI7XG52YXIgYWxnb3JpdGhtID0geyBuYW1lOiBcIkhNQUNcIiwgaGFzaDogXCJTSEEtMjU2XCIgfTtcbnZhciBnZXRDcnlwdG9LZXkgPSBhc3luYyAoc2VjcmV0KSA9PiB7XG4gIGNvbnN0IHNlY3JldEJ1ZiA9IHR5cGVvZiBzZWNyZXQgPT09IFwic3RyaW5nXCIgPyBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc2VjcmV0KSA6IHNlY3JldDtcbiAgcmV0dXJuIGF3YWl0IHN1YnRsZS5pbXBvcnRLZXkoXCJyYXdcIiwgc2VjcmV0QnVmLCBhbGdvcml0aG0sIGZhbHNlLCBbXCJzaWduXCIsIFwidmVyaWZ5XCJdKTtcbn07XG52YXIgbWFrZVNpZ25hdHVyZSA9IGFzeW5jICh2YWx1ZSwgc2VjcmV0KSA9PiB7XG4gIGNvbnN0IGtleSA9IGF3YWl0IGdldENyeXB0b0tleShzZWNyZXQpO1xuICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBzdWJ0bGUuc2lnbihhbGdvcml0aG0ubmFtZSwga2V5LCBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodmFsdWUpKTtcbiAgcmV0dXJuIGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5uZXcgVWludDhBcnJheShzaWduYXR1cmUpKSk7XG59O1xudmFyIHZlcmlmeVNpZ25hdHVyZSA9IGFzeW5jIChiYXNlNjRTaWduYXR1cmUsIHZhbHVlLCBzZWNyZXQpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzaWduYXR1cmVCaW5TdHIgPSBhdG9iKGJhc2U2NFNpZ25hdHVyZSk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gbmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlQmluU3RyLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHNpZ25hdHVyZUJpblN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgc2lnbmF0dXJlW2ldID0gc2lnbmF0dXJlQmluU3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCBzdWJ0bGUudmVyaWZ5KGFsZ29yaXRobSwgc2VjcmV0LCBzaWduYXR1cmUsIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh2YWx1ZSkpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xudmFyIHZhbGlkQ29va2llTmFtZVJlZ0V4ID0gL15bXFx3ISMkJSYnKi5eYHx+Ky1dKyQvO1xudmFyIHZhbGlkQ29va2llVmFsdWVSZWdFeCA9IC9eWyAhIy06PC1bXFxdLX5dKiQvO1xudmFyIHBhcnNlID0gKGNvb2tpZSwgbmFtZSkgPT4ge1xuICBjb25zdCBwYWlycyA9IGNvb2tpZS50cmltKCkuc3BsaXQoXCI7XCIpO1xuICByZXR1cm4gcGFpcnMucmVkdWNlKChwYXJzZWRDb29raWUsIHBhaXJTdHIpID0+IHtcbiAgICBwYWlyU3RyID0gcGFpclN0ci50cmltKCk7XG4gICAgY29uc3QgdmFsdWVTdGFydFBvcyA9IHBhaXJTdHIuaW5kZXhPZihcIj1cIik7XG4gICAgaWYgKHZhbHVlU3RhcnRQb3MgPT09IC0xKSB7XG4gICAgICByZXR1cm4gcGFyc2VkQ29va2llO1xuICAgIH1cbiAgICBjb25zdCBjb29raWVOYW1lID0gcGFpclN0ci5zdWJzdHJpbmcoMCwgdmFsdWVTdGFydFBvcykudHJpbSgpO1xuICAgIGlmIChuYW1lICYmIG5hbWUgIT09IGNvb2tpZU5hbWUgfHwgIXZhbGlkQ29va2llTmFtZVJlZ0V4LnRlc3QoY29va2llTmFtZSkpIHtcbiAgICAgIHJldHVybiBwYXJzZWRDb29raWU7XG4gICAgfVxuICAgIGxldCBjb29raWVWYWx1ZSA9IHBhaXJTdHIuc3Vic3RyaW5nKHZhbHVlU3RhcnRQb3MgKyAxKS50cmltKCk7XG4gICAgaWYgKGNvb2tpZVZhbHVlLnN0YXJ0c1dpdGgoJ1wiJykgJiYgY29va2llVmFsdWUuZW5kc1dpdGgoJ1wiJykpIHtcbiAgICAgIGNvb2tpZVZhbHVlID0gY29va2llVmFsdWUuc2xpY2UoMSwgLTEpO1xuICAgIH1cbiAgICBpZiAodmFsaWRDb29raWVWYWx1ZVJlZ0V4LnRlc3QoY29va2llVmFsdWUpKSB7XG4gICAgICBwYXJzZWRDb29raWVbY29va2llTmFtZV0gPSBkZWNvZGVVUklDb21wb25lbnQoY29va2llVmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VkQ29va2llO1xuICB9LCB7fSk7XG59O1xudmFyIHBhcnNlU2lnbmVkID0gYXN5bmMgKGNvb2tpZSwgc2VjcmV0LCBuYW1lKSA9PiB7XG4gIGNvbnN0IHBhcnNlZENvb2tpZSA9IHt9O1xuICBjb25zdCBzZWNyZXRLZXkgPSBhd2FpdCBnZXRDcnlwdG9LZXkoc2VjcmV0KTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFyc2UoY29va2llLCBuYW1lKSkpIHtcbiAgICBjb25zdCBzaWduYXR1cmVTdGFydFBvcyA9IHZhbHVlLmxhc3RJbmRleE9mKFwiLlwiKTtcbiAgICBpZiAoc2lnbmF0dXJlU3RhcnRQb3MgPCAxKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbmVkVmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMCwgc2lnbmF0dXJlU3RhcnRQb3MpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IHZhbHVlLnN1YnN0cmluZyhzaWduYXR1cmVTdGFydFBvcyArIDEpO1xuICAgIGlmIChzaWduYXR1cmUubGVuZ3RoICE9PSA0NCB8fCAhc2lnbmF0dXJlLmVuZHNXaXRoKFwiPVwiKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGlzVmVyaWZpZWQgPSBhd2FpdCB2ZXJpZnlTaWduYXR1cmUoc2lnbmF0dXJlLCBzaWduZWRWYWx1ZSwgc2VjcmV0S2V5KTtcbiAgICBwYXJzZWRDb29raWVba2V5XSA9IGlzVmVyaWZpZWQgPyBzaWduZWRWYWx1ZSA6IGZhbHNlO1xuICB9XG4gIHJldHVybiBwYXJzZWRDb29raWU7XG59O1xudmFyIF9zZXJpYWxpemUgPSAobmFtZSwgdmFsdWUsIG9wdCA9IHt9KSA9PiB7XG4gIGxldCBjb29raWUgPSBgJHtuYW1lfT0ke3ZhbHVlfWA7XG4gIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCJfX1NlY3VyZS1cIikgJiYgIW9wdC5zZWN1cmUpIHtcbiAgICBvcHQuc2VjdXJlID0gdHJ1ZTtcbiAgfVxuICBpZiAobmFtZS5zdGFydHNXaXRoKFwiX19Ib3N0LVwiKSkge1xuICAgIGlmICghb3B0LnNlY3VyZSkge1xuICAgICAgb3B0LnNlY3VyZSA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHQucGF0aCAhPT0gXCIvXCIpIHtcbiAgICAgIG9wdC5wYXRoID0gXCIvXCI7XG4gICAgfVxuICAgIGlmIChvcHQuZG9tYWluKSB7XG4gICAgICBvcHQuZG9tYWluID0gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBpZiAob3B0ICYmIHR5cGVvZiBvcHQubWF4QWdlID09PSBcIm51bWJlclwiICYmIG9wdC5tYXhBZ2UgPj0gMCkge1xuICAgIGlmIChvcHQubWF4QWdlID4gMzQ1NmU0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIFwiQ29va2llcyBNYXgtQWdlIFNIT1VMRCBOT1QgYmUgZ3JlYXRlciB0aGFuIDQwMCBkYXlzICgzNDU2MDAwMCBzZWNvbmRzKSBpbiBkdXJhdGlvbi5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29va2llICs9IGA7IE1heC1BZ2U9JHtNYXRoLmZsb29yKG9wdC5tYXhBZ2UpfWA7XG4gIH1cbiAgaWYgKG9wdC5kb21haW4gJiYgb3B0LnByZWZpeCAhPT0gXCJob3N0XCIpIHtcbiAgICBjb29raWUgKz0gYDsgRG9tYWluPSR7b3B0LmRvbWFpbn1gO1xuICB9XG4gIGlmIChvcHQucGF0aCkge1xuICAgIGNvb2tpZSArPSBgOyBQYXRoPSR7b3B0LnBhdGh9YDtcbiAgfVxuICBpZiAob3B0LmV4cGlyZXMpIHtcbiAgICBpZiAob3B0LmV4cGlyZXMuZ2V0VGltZSgpIC0gRGF0ZS5ub3coKSA+IDM0NTZlNykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkNvb2tpZXMgRXhwaXJlcyBTSE9VTEQgTk9UIGJlIGdyZWF0ZXIgdGhhbiA0MDAgZGF5cyAoMzQ1NjAwMDAgc2Vjb25kcykgaW4gdGhlIGZ1dHVyZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgY29va2llICs9IGA7IEV4cGlyZXM9JHtvcHQuZXhwaXJlcy50b1VUQ1N0cmluZygpfWA7XG4gIH1cbiAgaWYgKG9wdC5odHRwT25seSkge1xuICAgIGNvb2tpZSArPSBcIjsgSHR0cE9ubHlcIjtcbiAgfVxuICBpZiAob3B0LnNlY3VyZSkge1xuICAgIGNvb2tpZSArPSBcIjsgU2VjdXJlXCI7XG4gIH1cbiAgaWYgKG9wdC5zYW1lU2l0ZSkge1xuICAgIGNvb2tpZSArPSBgOyBTYW1lU2l0ZT0ke29wdC5zYW1lU2l0ZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG9wdC5zYW1lU2l0ZS5zbGljZSgxKX1gO1xuICB9XG4gIGlmIChvcHQucGFydGl0aW9uZWQpIHtcbiAgICBpZiAoIW9wdC5zZWN1cmUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhcnRpdGlvbmVkIENvb2tpZSBtdXN0IGhhdmUgU2VjdXJlIGF0dHJpYnV0ZXNcIik7XG4gICAgfVxuICAgIGNvb2tpZSArPSBcIjsgUGFydGl0aW9uZWRcIjtcbiAgfVxuICByZXR1cm4gY29va2llO1xufTtcbnZhciBzZXJpYWxpemUgPSAobmFtZSwgdmFsdWUsIG9wdCkgPT4ge1xuICB2YWx1ZSA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG4gIHJldHVybiBfc2VyaWFsaXplKG5hbWUsIHZhbHVlLCBvcHQpO1xufTtcbnZhciBzZXJpYWxpemVTaWduZWQgPSBhc3luYyAobmFtZSwgdmFsdWUsIHNlY3JldCwgb3B0ID0ge30pID0+IHtcbiAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgbWFrZVNpZ25hdHVyZSh2YWx1ZSwgc2VjcmV0KTtcbiAgdmFsdWUgPSBgJHt2YWx1ZX0uJHtzaWduYXR1cmV9YDtcbiAgdmFsdWUgPSBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICByZXR1cm4gX3NlcmlhbGl6ZShuYW1lLCB2YWx1ZSwgb3B0KTtcbn07XG52YXIgc2lnbkNvb2tpZVZhbHVlID0gYXN5bmMgKHZhbHVlLCBzZWNyZXQpID0+IHtcbiAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgbWFrZVNpZ25hdHVyZSh2YWx1ZSwgc2VjcmV0KTtcbiAgdmFsdWUgPSBgJHt2YWx1ZX0uJHtzaWduYXR1cmV9YDtcbiAgdmFsdWUgPSBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICByZXR1cm4gdmFsdWU7XG59O1xuXG4vLyBzcmMvY29va2llLXV0aWxzLnRzXG52YXIgZ2V0Q29va2llID0gKGNvb2tpZSwga2V5LCBwcmVmaXgpID0+IHtcbiAgaWYgKCFjb29raWUpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGxldCBmaW5hbEtleSA9IGtleTtcbiAgaWYgKHByZWZpeCkge1xuICAgIGlmIChwcmVmaXggPT09IFwic2VjdXJlXCIpIHtcbiAgICAgIGZpbmFsS2V5ID0gXCJfX1NlY3VyZS1cIiArIGtleTtcbiAgICB9IGVsc2UgaWYgKHByZWZpeCA9PT0gXCJob3N0XCIpIHtcbiAgICAgIGZpbmFsS2V5ID0gXCJfX0hvc3QtXCIgKyBrZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIGNvbnN0IG9iaiA9IHBhcnNlKGNvb2tpZSwgZmluYWxLZXkpO1xuICByZXR1cm4gb2JqW2ZpbmFsS2V5XTtcbn07XG52YXIgc2V0Q29va2llID0gKGhlYWRlciwgbmFtZSwgdmFsdWUsIG9wdCkgPT4ge1xuICBjb25zdCBleGlzdGluZ0Nvb2tpZXMgPSBoZWFkZXIuZ2V0KFwiU2V0LUNvb2tpZVwiKTtcbiAgaWYgKGV4aXN0aW5nQ29va2llcykge1xuICAgIGNvbnN0IGNvb2tpZXMgPSBleGlzdGluZ0Nvb2tpZXMuc3BsaXQoXCIsIFwiKTtcbiAgICBjb25zdCB1cGRhdGVkQ29va2llcyA9IGNvb2tpZXMuZmlsdGVyKChjb29raWUyKSA9PiAhY29va2llMi5zdGFydHNXaXRoKGAke25hbWV9PWApKTtcbiAgICBoZWFkZXIuZGVsZXRlKFwiU2V0LUNvb2tpZVwiKTtcbiAgICB1cGRhdGVkQ29va2llcy5mb3JFYWNoKChjb29raWUyKSA9PiBoZWFkZXIuYXBwZW5kKFwiU2V0LUNvb2tpZVwiLCBjb29raWUyKSk7XG4gIH1cbiAgbGV0IGNvb2tpZTtcbiAgaWYgKG9wdD8ucHJlZml4ID09PSBcInNlY3VyZVwiKSB7XG4gICAgY29va2llID0gc2VyaWFsaXplKFwiX19TZWN1cmUtXCIgKyBuYW1lLCB2YWx1ZSwgeyBwYXRoOiBcIi9cIiwgLi4ub3B0LCBzZWN1cmU6IHRydWUgfSk7XG4gIH0gZWxzZSBpZiAob3B0Py5wcmVmaXggPT09IFwiaG9zdFwiKSB7XG4gICAgY29va2llID0gc2VyaWFsaXplKFwiX19Ib3N0LVwiICsgbmFtZSwgdmFsdWUsIHtcbiAgICAgIC4uLm9wdCxcbiAgICAgIHBhdGg6IFwiL1wiLFxuICAgICAgc2VjdXJlOiB0cnVlLFxuICAgICAgZG9tYWluOiB2b2lkIDBcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb29raWUgPSBzZXJpYWxpemUobmFtZSwgdmFsdWUsIHsgcGF0aDogXCIvXCIsIC4uLm9wdCB9KTtcbiAgfVxuICBoZWFkZXIuYXBwZW5kKFwiU2V0LUNvb2tpZVwiLCBjb29raWUpO1xufTtcbnZhciBzZXRTaWduZWRDb29raWUgPSBhc3luYyAoaGVhZGVyLCBuYW1lLCB2YWx1ZSwgc2VjcmV0LCBvcHQpID0+IHtcbiAgbGV0IGNvb2tpZTtcbiAgaWYgKG9wdD8ucHJlZml4ID09PSBcInNlY3VyZVwiKSB7XG4gICAgY29va2llID0gYXdhaXQgc2VyaWFsaXplU2lnbmVkKFwiX19TZWN1cmUtXCIgKyBuYW1lLCB2YWx1ZSwgc2VjcmV0LCB7XG4gICAgICBwYXRoOiBcIi9cIixcbiAgICAgIC4uLm9wdCxcbiAgICAgIHNlY3VyZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKG9wdD8ucHJlZml4ID09PSBcImhvc3RcIikge1xuICAgIGNvb2tpZSA9IGF3YWl0IHNlcmlhbGl6ZVNpZ25lZChcIl9fSG9zdC1cIiArIG5hbWUsIHZhbHVlLCBzZWNyZXQsIHtcbiAgICAgIC4uLm9wdCxcbiAgICAgIHBhdGg6IFwiL1wiLFxuICAgICAgc2VjdXJlOiB0cnVlLFxuICAgICAgZG9tYWluOiB2b2lkIDBcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBjb29raWUgPSBhd2FpdCBzZXJpYWxpemVTaWduZWQobmFtZSwgdmFsdWUsIHNlY3JldCwgeyBwYXRoOiBcIi9cIiwgLi4ub3B0IH0pO1xuICB9XG4gIGhlYWRlci5hcHBlbmQoXCJTZXQtQ29va2llXCIsIGNvb2tpZSk7XG59O1xudmFyIGdldFNpZ25lZENvb2tpZSA9IGFzeW5jIChoZWFkZXIsIHNlY3JldCwga2V5LCBwcmVmaXgpID0+IHtcbiAgY29uc3QgY29va2llID0gaGVhZGVyLmdldChcImNvb2tpZVwiKTtcbiAgaWYgKCFjb29raWUpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGxldCBmaW5hbEtleSA9IGtleTtcbiAgaWYgKHByZWZpeCkge1xuICAgIGlmIChwcmVmaXggPT09IFwic2VjdXJlXCIpIHtcbiAgICAgIGZpbmFsS2V5ID0gXCJfX1NlY3VyZS1cIiArIGtleTtcbiAgICB9IGVsc2UgaWYgKHByZWZpeCA9PT0gXCJob3N0XCIpIHtcbiAgICAgIGZpbmFsS2V5ID0gXCJfX0hvc3QtXCIgKyBrZXk7XG4gICAgfVxuICB9XG4gIGNvbnN0IG9iaiA9IGF3YWl0IHBhcnNlU2lnbmVkKGNvb2tpZSwgc2VjcmV0LCBmaW5hbEtleSk7XG4gIHJldHVybiBvYmpbZmluYWxLZXldO1xufTtcblxuLy8gc3JjL2VuZHBvaW50LnRzXG5mdW5jdGlvbiBjcmVhdGVFbmRwb2ludENyZWF0b3Iob3B0cykge1xuICByZXR1cm4gKHBhdGgsIG9wdGlvbnMsIGhhbmRsZXIpID0+IHtcbiAgICByZXR1cm4gY3JlYXRlRW5kcG9pbnQoXG4gICAgICBwYXRoLFxuICAgICAge1xuICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB1c2U6IFsuLi5vcHRpb25zPy51c2UgfHwgW10sIC4uLm9wdHM/LnVzZSB8fCBbXV1cbiAgICAgIH0sXG4gICAgICBoYW5kbGVyXG4gICAgKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUVuZHBvaW50KHBhdGgsIG9wdGlvbnMsIGhhbmRsZXIpIHtcbiAgbGV0IHJlc3BvbnNlSGVhZGVyID0gbmV3IEhlYWRlcnMoKTtcbiAgY29uc3QgaGFuZGxlID0gYXN5bmMgKC4uLmN0eCkgPT4ge1xuICAgIGxldCBpbnRlcm5hbEN0eCA9IHtcbiAgICAgIHNldEhlYWRlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHJlc3BvbnNlSGVhZGVyLnNldChrZXksIHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBzZXRDb29raWUoa2V5LCB2YWx1ZSwgb3B0aW9uczIpIHtcbiAgICAgICAgc2V0Q29va2llKHJlc3BvbnNlSGVhZGVyLCBrZXksIHZhbHVlLCBvcHRpb25zMik7XG4gICAgICB9LFxuICAgICAgZ2V0Q29va2llKGtleSwgcHJlZml4KSB7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGN0eFswXT8uaGVhZGVycztcbiAgICAgICAgY29uc3QgY29va2llSCA9IGhlYWRlcj8uZ2V0KFwiY29va2llXCIpO1xuICAgICAgICBjb25zdCBjb29raWUgPSBnZXRDb29raWUoY29va2llSCB8fCBcIlwiLCBrZXksIHByZWZpeCk7XG4gICAgICAgIHJldHVybiBjb29raWU7XG4gICAgICB9LFxuICAgICAgZ2V0U2lnbmVkQ29va2llKGtleSwgc2VjcmV0LCBwcmVmaXgpIHtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gY3R4WzBdPy5oZWFkZXJzO1xuICAgICAgICBpZiAoIWhlYWRlcikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJIZWFkZXJzIGFyZSByZXF1aXJlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb29raWUgPSBnZXRTaWduZWRDb29raWUoaGVhZGVyLCBzZWNyZXQsIGtleSwgcHJlZml4KTtcbiAgICAgICAgcmV0dXJuIGNvb2tpZTtcbiAgICAgIH0sXG4gICAgICBhc3luYyBzZXRTaWduZWRDb29raWUoa2V5LCB2YWx1ZSwgc2VjcmV0LCBvcHRpb25zMikge1xuICAgICAgICBhd2FpdCBzZXRTaWduZWRDb29raWUocmVzcG9uc2VIZWFkZXIsIGtleSwgdmFsdWUsIHNlY3JldCwgb3B0aW9uczIpO1xuICAgICAgfSxcbiAgICAgIHJlZGlyZWN0KHVybCkge1xuICAgICAgICByZXNwb25zZUhlYWRlci5zZXQoXCJMb2NhdGlvblwiLCB1cmwpO1xuICAgICAgICByZXR1cm4gbmV3IEFQSUVycm9yKFwiRk9VTkRcIik7XG4gICAgICB9LFxuICAgICAganNvbixcbiAgICAgIGNvbnRleHQ6IGN0eFswXT8uY29udGV4dCB8fCB7fSxcbiAgICAgIF9mbGFnOiBjdHhbMF0/LmFzUmVzcG9uc2UgPyBcInJvdXRlclwiIDogY3R4WzBdPy5fZmxhZyxcbiAgICAgIHJlc3BvbnNlSGVhZGVyLFxuICAgICAgcGF0aCxcbiAgICAgIC4uLmN0eFswXSB8fCB7fVxuICAgIH07XG4gICAgaWYgKG9wdGlvbnMudXNlPy5sZW5ndGgpIHtcbiAgICAgIGxldCBtaWRkbGV3YXJlQ29udGV4dHMgPSB7fTtcbiAgICAgIGxldCBtaWRkbGV3YXJlQm9keSA9IHt9O1xuICAgICAgZm9yIChjb25zdCBtaWRkbGV3YXJlIG9mIG9wdGlvbnMudXNlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWlkZGxld2FyZSAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiTWlkZGxld2FyZSBpcyBub3QgYSBmdW5jdGlvblwiLCB7XG4gICAgICAgICAgICBtaWRkbGV3YXJlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgbWlkZGxld2FyZShpbnRlcm5hbEN0eCk7XG4gICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICBjb25zdCBib2R5ID0gcmVzLm9wdGlvbnM/LmJvZHkgPyByZXMub3B0aW9ucy5ib2R5LnBhcnNlKGludGVybmFsQ3R4LmJvZHkpIDogdm9pZCAwO1xuICAgICAgICAgIG1pZGRsZXdhcmVDb250ZXh0cyA9IHtcbiAgICAgICAgICAgIC4uLm1pZGRsZXdhcmVDb250ZXh0cyxcbiAgICAgICAgICAgIC4uLnJlc1xuICAgICAgICAgIH07XG4gICAgICAgICAgbWlkZGxld2FyZUJvZHkgPSB7XG4gICAgICAgICAgICAuLi5taWRkbGV3YXJlQm9keSxcbiAgICAgICAgICAgIC4uLmJvZHlcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpbnRlcm5hbEN0eCA9IHtcbiAgICAgICAgLi4uaW50ZXJuYWxDdHgsXG4gICAgICAgIGJvZHk6IHtcbiAgICAgICAgICAuLi5taWRkbGV3YXJlQm9keSxcbiAgICAgICAgICAuLi5pbnRlcm5hbEN0eC5ib2R5XG4gICAgICAgIH0sXG4gICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAuLi5pbnRlcm5hbEN0eC5jb250ZXh0IHx8IHt9LFxuICAgICAgICAgIC4uLm1pZGRsZXdhcmVDb250ZXh0c1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgYm9keSA9IG9wdGlvbnMuYm9keSA/IG9wdGlvbnMuYm9keS5wYXJzZShpbnRlcm5hbEN0eC5ib2R5KSA6IGludGVybmFsQ3R4LmJvZHk7XG4gICAgICBpbnRlcm5hbEN0eCA9IHtcbiAgICAgICAgLi4uaW50ZXJuYWxDdHgsXG4gICAgICAgIGJvZHk6IGJvZHkgPyB7XG4gICAgICAgICAgLi4uYm9keSxcbiAgICAgICAgICAuLi5pbnRlcm5hbEN0eC5ib2R5XG4gICAgICAgIH0gOiBpbnRlcm5hbEN0eC5ib2R5XG4gICAgICB9O1xuICAgICAgaW50ZXJuYWxDdHgucXVlcnkgPSBvcHRpb25zLnF1ZXJ5ID8gb3B0aW9ucy5xdWVyeS5wYXJzZShpbnRlcm5hbEN0eC5xdWVyeSkgOiBpbnRlcm5hbEN0eC5xdWVyeTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIFpvZEVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBBUElFcnJvcihcIkJBRF9SRVFVRVNUXCIsIHtcbiAgICAgICAgICBtZXNzYWdlOiBlLm1lc3NhZ2UsXG4gICAgICAgICAgZGV0YWlsczogZS5lcnJvcnNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZXF1aXJlSGVhZGVycyAmJiAhaW50ZXJuYWxDdHguaGVhZGVycykge1xuICAgICAgdGhyb3cgbmV3IEFQSUVycm9yKFwiQkFEX1JFUVVFU1RcIiwge1xuICAgICAgICBtZXNzYWdlOiBcIkhlYWRlcnMgYXJlIHJlcXVpcmVkXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZXF1aXJlUmVxdWVzdCAmJiAhaW50ZXJuYWxDdHgucmVxdWVzdCkge1xuICAgICAgdGhyb3cgbmV3IEFQSUVycm9yKFwiQkFEX1JFUVVFU1RcIiwge1xuICAgICAgICBtZXNzYWdlOiBcIlJlcXVlc3QgaXMgcmVxdWlyZWRcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpbnRlcm5hbEN0eC5yZXF1ZXN0ICYmICFpbnRlcm5hbEN0eC5oZWFkZXJzKSB7XG4gICAgICBpbnRlcm5hbEN0eC5oZWFkZXJzID0gaW50ZXJuYWxDdHgucmVxdWVzdC5oZWFkZXJzO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgbGV0IHJlcyA9IGF3YWl0IGhhbmRsZXIoaW50ZXJuYWxDdHgpO1xuICAgICAgbGV0IGFjdHVhbFJlc3BvbnNlID0gcmVzO1xuICAgICAgaWYgKHJlcyAmJiB0eXBlb2YgcmVzID09PSBcIm9iamVjdFwiICYmIFwiX2ZsYWdcIiBpbiByZXMpIHtcbiAgICAgICAgaWYgKHJlcy5fZmxhZyA9PT0gXCJqc29uXCIgJiYgaW50ZXJuYWxDdHguX2ZsYWcgPT09IFwicm91dGVyXCIpIHtcbiAgICAgICAgICBjb25zdCBoID0gcmVzLnJlc3BvbnNlLmhlYWRlcnM7XG4gICAgICAgICAgT2JqZWN0LmtleXMoaCB8fCB7fSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICByZXNwb25zZUhlYWRlci5zZXQoa2V5LCBoW2tleV0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJlc3BvbnNlSGVhZGVyLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICAgICAgYWN0dWFsUmVzcG9uc2UgPSBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkocmVzLnJlc3BvbnNlLmJvZHkpLCB7XG4gICAgICAgICAgICBzdGF0dXM6IHJlcy5yZXNwb25zZS5zdGF0dXMgPz8gMjAwLFxuICAgICAgICAgICAgc3RhdHVzVGV4dDogcmVzLnJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlclxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFjdHVhbFJlc3BvbnNlID0gcmVzLmJvZHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3BvbnNlSGVhZGVyID0gbmV3IEhlYWRlcnMoKTtcbiAgICAgIHJldHVybiBhY3R1YWxSZXNwb25zZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIEFQSUVycm9yKSB7XG4gICAgICAgIHJlc3BvbnNlSGVhZGVyLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICAgIGUuaGVhZGVycyA9IHJlc3BvbnNlSGVhZGVyO1xuICAgICAgICByZXNwb25zZUhlYWRlciA9IG5ldyBIZWFkZXJzKCk7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICB0aHJvdyBlO1xuICAgIH1cbiAgfTtcbiAgaGFuZGxlLnBhdGggPSBwYXRoO1xuICBoYW5kbGUub3B0aW9ucyA9IG9wdGlvbnM7XG4gIGhhbmRsZS5tZXRob2QgPSBvcHRpb25zLm1ldGhvZDtcbiAgaGFuZGxlLmhlYWRlcnMgPSByZXNwb25zZUhlYWRlcjtcbiAgcmV0dXJuIGhhbmRsZTtcbn1cblxuLy8gc3JjL3JvdXRlci50c1xuaW1wb3J0IHsgY3JlYXRlUm91dGVyIGFzIGNyZWF0ZVJvdTNSb3V0ZXIsIGFkZFJvdXRlLCBmaW5kUm91dGUsIGZpbmRBbGxSb3V0ZXMgfSBmcm9tIFwicm91M1wiO1xuXG4vLyBzcmMvdXRpbHMudHNcbmFzeW5jIGZ1bmN0aW9uIGdldEJvZHkocmVxdWVzdCkge1xuICBjb25zdCBjb250ZW50VHlwZSA9IHJlcXVlc3QuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikgfHwgXCJcIjtcbiAgaWYgKCFyZXF1ZXN0LmJvZHkpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHtcbiAgICByZXR1cm4gYXdhaXQgcmVxdWVzdC5qc29uKCk7XG4gIH1cbiAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpKSB7XG4gICAgY29uc3QgZm9ybURhdGEgPSBhd2FpdCByZXF1ZXN0LmZvcm1EYXRhKCk7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9ybURhdGEuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwibXVsdGlwYXJ0L2Zvcm0tZGF0YVwiKSkge1xuICAgIGNvbnN0IGZvcm1EYXRhID0gYXdhaXQgcmVxdWVzdC5mb3JtRGF0YSgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvcm1EYXRhLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoY29udGVudFR5cGUuaW5jbHVkZXMoXCJ0ZXh0L3BsYWluXCIpKSB7XG4gICAgcmV0dXJuIGF3YWl0IHJlcXVlc3QudGV4dCgpO1xuICB9XG4gIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiKSkge1xuICAgIHJldHVybiBhd2FpdCByZXF1ZXN0LmFycmF5QnVmZmVyKCk7XG4gIH1cbiAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vcGRmXCIpIHx8IGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwiaW1hZ2UvXCIpIHx8IGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwidmlkZW8vXCIpKSB7XG4gICAgY29uc3QgYmxvYiA9IGF3YWl0IHJlcXVlc3QuYmxvYigpO1xuICAgIHJldHVybiBibG9iO1xuICB9XG4gIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL3N0cmVhbVwiKSB8fCByZXF1ZXN0LmJvZHkgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbSkge1xuICAgIHJldHVybiByZXF1ZXN0LmJvZHk7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IHJlcXVlc3QudGV4dCgpO1xufVxuZnVuY3Rpb24gc2hvdWxkU2VyaWFsaXplKGJvZHkpIHtcbiAgcmV0dXJuIHR5cGVvZiBib2R5ID09PSBcIm9iamVjdFwiICYmIGJvZHkgIT09IG51bGwgJiYgIShib2R5IGluc3RhbmNlb2YgQmxvYikgJiYgIShib2R5IGluc3RhbmNlb2YgRm9ybURhdGEpO1xufVxudmFyIHN0YXR1c0NvZGUgPSB7XG4gIE9LOiAyMDAsXG4gIENSRUFURUQ6IDIwMSxcbiAgQUNDRVBURUQ6IDIwMixcbiAgTk9fQ09OVEVOVDogMjA0LFxuICBNVUxUSVBMRV9DSE9JQ0VTOiAzMDAsXG4gIE1PVkVEX1BFUk1BTkVOVExZOiAzMDEsXG4gIEZPVU5EOiAzMDIsXG4gIFNFRV9PVEhFUjogMzAzLFxuICBOT1RfTU9ESUZJRUQ6IDMwNCxcbiAgVEVNUE9SQVJZX1JFRElSRUNUOiAzMDcsXG4gIEJBRF9SRVFVRVNUOiA0MDAsXG4gIFVOQVVUSE9SSVpFRDogNDAxLFxuICBQQVlNRU5UX1JFUVVJUkVEOiA0MDIsXG4gIEZPUkJJRERFTjogNDAzLFxuICBOT1RfRk9VTkQ6IDQwNCxcbiAgTUVUSE9EX05PVF9BTExPV0VEOiA0MDUsXG4gIE5PVF9BQ0NFUFRBQkxFOiA0MDYsXG4gIFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEOiA0MDcsXG4gIFJFUVVFU1RfVElNRU9VVDogNDA4LFxuICBDT05GTElDVDogNDA5LFxuICBHT05FOiA0MTAsXG4gIExFTkdUSF9SRVFVSVJFRDogNDExLFxuICBQUkVDT05ESVRJT05fRkFJTEVEOiA0MTIsXG4gIFBBWUxPQURfVE9PX0xBUkdFOiA0MTMsXG4gIFVSSV9UT09fTE9ORzogNDE0LFxuICBVTlNVUFBPUlRFRF9NRURJQV9UWVBFOiA0MTUsXG4gIFJBTkdFX05PVF9TQVRJU0ZJQUJMRTogNDE2LFxuICBFWFBFQ1RBVElPTl9GQUlMRUQ6IDQxNyxcbiAgXCJJJ01fQV9URUFQT1RcIjogNDE4LFxuICBNSVNESVJFQ1RFRF9SRVFVRVNUOiA0MjEsXG4gIFVOUFJPQ0VTU0FCTEVfRU5USVRZOiA0MjIsXG4gIExPQ0tFRDogNDIzLFxuICBGQUlMRURfREVQRU5ERU5DWTogNDI0LFxuICBUT09fRUFSTFk6IDQyNSxcbiAgVVBHUkFERV9SRVFVSVJFRDogNDI2LFxuICBQUkVDT05ESVRJT05fUkVRVUlSRUQ6IDQyOCxcbiAgVE9PX01BTllfUkVRVUVTVFM6IDQyOSxcbiAgUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRTogNDMxLFxuICBVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUzogNDUxLFxuICBJTlRFUk5BTF9TRVJWRVJfRVJST1I6IDUwMCxcbiAgTk9UX0lNUExFTUVOVEVEOiA1MDEsXG4gIEJBRF9HQVRFV0FZOiA1MDIsXG4gIFNFUlZJQ0VfVU5BVkFJTEFCTEU6IDUwMyxcbiAgR0FURVdBWV9USU1FT1VUOiA1MDQsXG4gIEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEOiA1MDUsXG4gIFZBUklBTlRfQUxTT19ORUdPVElBVEVTOiA1MDYsXG4gIElOU1VGRklDSUVOVF9TVE9SQUdFOiA1MDcsXG4gIExPT1BfREVURUNURUQ6IDUwOCxcbiAgTk9UX0VYVEVOREVEOiA1MTAsXG4gIE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQ6IDUxMVxufTtcblxuLy8gc3JjL3JvdXRlci50c1xudmFyIGNyZWF0ZVJvdXRlciA9IChlbmRwb2ludHMsIGNvbmZpZykgPT4ge1xuICBjb25zdCBfZW5kcG9pbnRzID0gT2JqZWN0LnZhbHVlcyhlbmRwb2ludHMpO1xuICBjb25zdCByb3V0ZXIgPSBjcmVhdGVSb3UzUm91dGVyKCk7XG4gIGZvciAoY29uc3QgZW5kcG9pbnQgb2YgX2VuZHBvaW50cykge1xuICAgIGlmIChlbmRwb2ludC5vcHRpb25zLm1ldGFkYXRhPy5TRVJWRVJfT05MWSkgY29udGludWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZW5kcG9pbnQub3B0aW9ucz8ubWV0aG9kKSkge1xuICAgICAgZm9yIChjb25zdCBtZXRob2Qgb2YgZW5kcG9pbnQub3B0aW9ucy5tZXRob2QpIHtcbiAgICAgICAgYWRkUm91dGUocm91dGVyLCBtZXRob2QsIGVuZHBvaW50LnBhdGgsIGVuZHBvaW50KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYWRkUm91dGUocm91dGVyLCBlbmRwb2ludC5vcHRpb25zLm1ldGhvZCwgZW5kcG9pbnQucGF0aCwgZW5kcG9pbnQpO1xuICAgIH1cbiAgfVxuICBjb25zdCBtaWRkbGV3YXJlUm91dGVyID0gY3JlYXRlUm91M1JvdXRlcigpO1xuICBmb3IgKGNvbnN0IHJvdXRlIG9mIGNvbmZpZz8ucm91dGVyTWlkZGxld2FyZSB8fCBbXSkge1xuICAgIGFkZFJvdXRlKG1pZGRsZXdhcmVSb3V0ZXIsIFwiKlwiLCByb3V0ZS5wYXRoLCByb3V0ZS5taWRkbGV3YXJlKTtcbiAgfVxuICBjb25zdCBoYW5kbGVyID0gYXN5bmMgKHJlcXVlc3QpID0+IHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKHJlcXVlc3QudXJsKTtcbiAgICBsZXQgcGF0aCA9IHVybC5wYXRobmFtZTtcbiAgICBpZiAoY29uZmlnPy5iYXNlUGF0aCkge1xuICAgICAgcGF0aCA9IHBhdGguc3BsaXQoY29uZmlnLmJhc2VQYXRoKVsxXTtcbiAgICB9XG4gICAgaWYgKCFwYXRoPy5sZW5ndGgpIHtcbiAgICAgIGNvbmZpZz8ub25FcnJvcj8uKG5ldyBBUElFcnJvcihcIk5PVF9GT1VORFwiKSk7XG4gICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgIGBbYmV0dGVyLWNhbGxdOiBNYWtlIHN1cmUgdGhlIFVSTCBoYXMgdGhlIGJhc2VQYXRoICgke2NvbmZpZz8uYmFzZVBhdGh9KS5gXG4gICAgICApO1xuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgIHN0YXR1czogNDA0LFxuICAgICAgICBzdGF0dXNUZXh0OiBcIk5vdCBGb3VuZFwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbWV0aG9kID0gcmVxdWVzdC5tZXRob2Q7XG4gICAgY29uc3Qgcm91dGUgPSBmaW5kUm91dGUocm91dGVyLCBtZXRob2QsIHBhdGgpO1xuICAgIGNvbnN0IGhhbmRsZXIyID0gcm91dGU/LmRhdGE7XG4gICAgY29uc3QgYm9keSA9IGF3YWl0IGdldEJvZHkocmVxdWVzdCk7XG4gICAgY29uc3QgaGVhZGVycyA9IHJlcXVlc3QuaGVhZGVycztcbiAgICBjb25zdCBxdWVyeSA9IE9iamVjdC5mcm9tRW50cmllcyh1cmwuc2VhcmNoUGFyYW1zKTtcbiAgICBjb25zdCByb3V0ZXJNaWRkbGV3YXJlID0gZmluZEFsbFJvdXRlcyhtaWRkbGV3YXJlUm91dGVyLCBcIipcIiwgcGF0aCk7XG4gICAgaWYgKCFoYW5kbGVyMikge1xuICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7XG4gICAgICAgIHN0YXR1czogNDA0LFxuICAgICAgICBzdGF0dXNUZXh0OiBcIk5vdCBGb3VuZFwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGxldCBtaWRkbGV3YXJlQ29udGV4dCA9IHt9O1xuICAgICAgaWYgKHJvdXRlck1pZGRsZXdhcmU/Lmxlbmd0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IHJvdXRlMiBvZiByb3V0ZXJNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgY29uc3QgbWlkZGxld2FyZSA9IHJvdXRlMi5kYXRhO1xuICAgICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IG1pZGRsZXdhcmUoe1xuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICBwYXJhbXM6IHJvdXRlMj8ucGFyYW1zLFxuICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgIGJvZHksXG4gICAgICAgICAgICBxdWVyeSxcbiAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgLi4uY29uZmlnPy5leHRyYUNvbnRleHRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXM/Ll9mbGFnID09PSBcImpzb25cIikge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShyZXMpLCB7XG4gICAgICAgICAgICAgIGhlYWRlcnM6IHJlcy5oZWFkZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlcykge1xuICAgICAgICAgICAgbWlkZGxld2FyZUNvbnRleHQgPSB7XG4gICAgICAgICAgICAgIC4uLnJlcyxcbiAgICAgICAgICAgICAgLi4ubWlkZGxld2FyZUNvbnRleHRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBoYW5kbGVyUmVzID0gYXdhaXQgaGFuZGxlcjIoe1xuICAgICAgICBwYXRoLFxuICAgICAgICBtZXRob2QsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgICAgIHBhcmFtczogcm91dGU/LnBhcmFtcyxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgYm9keSxcbiAgICAgICAgcXVlcnksXG4gICAgICAgIF9mbGFnOiBcInJvdXRlclwiLFxuICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgLi4ubWlkZGxld2FyZUNvbnRleHQsXG4gICAgICAgICAgLi4uY29uZmlnPy5leHRyYUNvbnRleHRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoaGFuZGxlclJlcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVyUmVzO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzQm9keSA9IHNob3VsZFNlcmlhbGl6ZShoYW5kbGVyUmVzKSA/IEpTT04uc3RyaW5naWZ5KGhhbmRsZXJSZXMpIDogaGFuZGxlclJlcztcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UocmVzQm9keSwge1xuICAgICAgICBoZWFkZXJzOiBoYW5kbGVyMi5oZWFkZXJzXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoY29uZmlnPy5vbkVycm9yKSB7XG4gICAgICAgIGNvbnN0IG9uRXJyb3JSZXMgPSBhd2FpdCBjb25maWcub25FcnJvcihlKTtcbiAgICAgICAgaWYgKG9uRXJyb3JSZXMgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgICAgIHJldHVybiBvbkVycm9yUmVzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZSBpbnN0YW5jZW9mIEFQSUVycm9yKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoZS5ib2R5ID8gSlNPTi5zdHJpbmdpZnkoZS5ib2R5KSA6IG51bGwsIHtcbiAgICAgICAgICBzdGF0dXM6IHN0YXR1c0NvZGVbZS5zdGF0dXNdLFxuICAgICAgICAgIHN0YXR1c1RleHQ6IGUuc3RhdHVzLFxuICAgICAgICAgIGhlYWRlcnM6IGUuaGVhZGVyc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChjb25maWc/LnRocm93RXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICBzdGF0dXM6IDUwMCxcbiAgICAgICAgc3RhdHVzVGV4dDogXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIlxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4ge1xuICAgIGhhbmRsZXI6IGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgICBjb25zdCBvblJlcSA9IGF3YWl0IGNvbmZpZz8ub25SZXF1ZXN0Py4ocmVxdWVzdCk7XG4gICAgICBpZiAob25SZXEgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gb25SZXE7XG4gICAgICB9XG4gICAgICBjb25zdCByZXEgPSBvblJlcSBpbnN0YW5jZW9mIFJlcXVlc3QgPyBvblJlcSA6IHJlcXVlc3Q7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBoYW5kbGVyKHJlcSk7XG4gICAgICBjb25zdCBvblJlcyA9IGF3YWl0IGNvbmZpZz8ub25SZXNwb25zZT8uKHJlcyk7XG4gICAgICBpZiAob25SZXMgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gb25SZXM7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0sXG4gICAgZW5kcG9pbnRzXG4gIH07XG59O1xuXG4vLyBzcmMvbWlkZGxld2FyZS50c1xuZnVuY3Rpb24gY3JlYXRlTWlkZGxld2FyZShvcHRpb25zT3JIYW5kbGVyLCBoYW5kbGVyKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9uc09ySGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVuZHBvaW50KFxuICAgICAgXCIqXCIsXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogXCIqXCJcbiAgICAgIH0sXG4gICAgICBvcHRpb25zT3JIYW5kbGVyXG4gICAgKTtcbiAgfVxuICBpZiAoIWhhbmRsZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJNaWRkbGV3YXJlIGhhbmRsZXIgaXMgcmVxdWlyZWRcIik7XG4gIH1cbiAgY29uc3QgZW5kcG9pbnQgPSBjcmVhdGVFbmRwb2ludChcbiAgICBcIipcIixcbiAgICB7XG4gICAgICAuLi5vcHRpb25zT3JIYW5kbGVyLFxuICAgICAgbWV0aG9kOiBcIipcIlxuICAgIH0sXG4gICAgaGFuZGxlclxuICApO1xuICByZXR1cm4gZW5kcG9pbnQ7XG59XG52YXIgY3JlYXRlTWlkZGxld2FyZUNyZWF0b3IgPSAob3B0cykgPT4ge1xuICBmdW5jdGlvbiBmbihvcHRpb25zT3JIYW5kbGVyLCBoYW5kbGVyKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zT3JIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIHJldHVybiBjcmVhdGVFbmRwb2ludChcbiAgICAgICAgXCIqXCIsXG4gICAgICAgIHtcbiAgICAgICAgICBtZXRob2Q6IFwiKlwiXG4gICAgICAgIH0sXG4gICAgICAgIG9wdGlvbnNPckhhbmRsZXJcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICghaGFuZGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlkZGxld2FyZSBoYW5kbGVyIGlzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBlbmRwb2ludCA9IGNyZWF0ZUVuZHBvaW50KFxuICAgICAgXCIqXCIsXG4gICAgICB7XG4gICAgICAgIC4uLm9wdGlvbnNPckhhbmRsZXIsXG4gICAgICAgIG1ldGhvZDogXCIqXCJcbiAgICAgIH0sXG4gICAgICBoYW5kbGVyXG4gICAgKTtcbiAgICByZXR1cm4gZW5kcG9pbnQ7XG4gIH1cbiAgcmV0dXJuIGZuO1xufTtcblxuLy8gc3JjL3R5cGVzLnRzXG5pbXBvcnQgXCJ6b2RcIjtcblxuLy8gc3JjL2FkYXB0ZXIvcmVxdWVzdC50c1xudmFyIHNldF9jb29raWVfcGFyc2VyID0gX190b0VTTShyZXF1aXJlX3NldF9jb29raWUoKSwgMSk7XG5mdW5jdGlvbiBnZXRfcmF3X2JvZHkocmVxLCBib2R5X3NpemVfbGltaXQpIHtcbiAgY29uc3QgaCA9IHJlcS5oZWFkZXJzO1xuICBpZiAoIWhbXCJjb250ZW50LXR5cGVcIl0pIHJldHVybiBudWxsO1xuICBjb25zdCBjb250ZW50X2xlbmd0aCA9IE51bWJlcihoW1wiY29udGVudC1sZW5ndGhcIl0pO1xuICBpZiAocmVxLmh0dHBWZXJzaW9uTWFqb3IgPT09IDEgJiYgaXNOYU4oY29udGVudF9sZW5ndGgpICYmIGhbXCJ0cmFuc2Zlci1lbmNvZGluZ1wiXSA9PSBudWxsIHx8IGNvbnRlbnRfbGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGV0IGxlbmd0aCA9IGNvbnRlbnRfbGVuZ3RoO1xuICBpZiAoYm9keV9zaXplX2xpbWl0KSB7XG4gICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgIGxlbmd0aCA9IGJvZHlfc2l6ZV9saW1pdDtcbiAgICB9IGVsc2UgaWYgKGxlbmd0aCA+IGJvZHlfc2l6ZV9saW1pdCkge1xuICAgICAgdGhyb3cgRXJyb3IoXG4gICAgICAgIGBSZWNlaXZlZCBjb250ZW50LWxlbmd0aCBvZiAke2xlbmd0aH0sIGJ1dCBvbmx5IGFjY2VwdCB1cCB0byAke2JvZHlfc2l6ZV9saW1pdH0gYnl0ZXMuYFxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHJlcS5kZXN0cm95ZWQpIHtcbiAgICBjb25zdCByZWFkYWJsZSA9IG5ldyBSZWFkYWJsZVN0cmVhbSgpO1xuICAgIHJlYWRhYmxlLmNhbmNlbCgpO1xuICAgIHJldHVybiByZWFkYWJsZTtcbiAgfVxuICBsZXQgc2l6ZSA9IDA7XG4gIGxldCBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgcmVxLm9uKFwiZXJyb3JcIiwgKGVycm9yKSA9PiB7XG4gICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgfSk7XG4gICAgICByZXEub24oXCJlbmRcIiwgKCkgPT4ge1xuICAgICAgICBpZiAoY2FuY2VsbGVkKSByZXR1cm47XG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH0pO1xuICAgICAgcmVxLm9uKFwiZGF0YVwiLCAoY2h1bmspID0+IHtcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICBzaXplICs9IGNodW5rLmxlbmd0aDtcbiAgICAgICAgaWYgKHNpemUgPiBsZW5ndGgpIHtcbiAgICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoXG4gICAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGByZXF1ZXN0IGJvZHkgc2l6ZSBleGNlZWRlZCAke2NvbnRlbnRfbGVuZ3RoID8gXCInY29udGVudC1sZW5ndGgnXCIgOiBcIkJPRFlfU0laRV9MSU1JVFwifSBvZiAke2xlbmd0aH1gXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuZGVzaXJlZFNpemUgPT09IG51bGwgfHwgY29udHJvbGxlci5kZXNpcmVkU2l6ZSA8PSAwKSB7XG4gICAgICAgICAgcmVxLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sXG4gICAgcHVsbCgpIHtcbiAgICAgIHJlcS5yZXN1bWUoKTtcbiAgICB9LFxuICAgIGNhbmNlbChyZWFzb24pIHtcbiAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgICByZXEuZGVzdHJveShyZWFzb24pO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBnZXRSZXF1ZXN0KHtcbiAgcmVxdWVzdCxcbiAgYmFzZSxcbiAgYm9keVNpemVMaW1pdFxufSkge1xuICByZXR1cm4gbmV3IFJlcXVlc3QoYmFzZSArIHJlcXVlc3QudXJsLCB7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIGR1cGxleDogXCJoYWxmXCIsXG4gICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICBib2R5OiBnZXRfcmF3X2JvZHkocmVxdWVzdCwgYm9keVNpemVMaW1pdCksXG4gICAgaGVhZGVyczogcmVxdWVzdC5oZWFkZXJzXG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gc2V0UmVzcG9uc2UocmVzLCByZXNwb25zZSkge1xuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiByZXNwb25zZS5oZWFkZXJzKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJlcy5zZXRIZWFkZXIoXG4gICAgICAgIGtleSxcbiAgICAgICAga2V5ID09PSBcInNldC1jb29raWVcIiA/IHNldF9jb29raWVfcGFyc2VyLnNwbGl0Q29va2llc1N0cmluZyhyZXNwb25zZS5oZWFkZXJzLmdldChrZXkpKSA6IHZhbHVlXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICByZXMuZ2V0SGVhZGVyTmFtZXMoKS5mb3JFYWNoKChuYW1lKSA9PiByZXMucmVtb3ZlSGVhZGVyKG5hbWUpKTtcbiAgICAgIHJlcy53cml0ZUhlYWQoNTAwKS5lbmQoU3RyaW5nKGVycm9yKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIHJlcy53cml0ZUhlYWQocmVzcG9uc2Uuc3RhdHVzKTtcbiAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgcmVzLmVuZCgpO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocmVzcG9uc2UuYm9keS5sb2NrZWQpIHtcbiAgICByZXMuZW5kKFxuICAgICAgXCJGYXRhbCBlcnJvcjogUmVzcG9uc2UgYm9keSBpcyBsb2NrZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHRoZSByZXNwb25zZSB3YXMgYWxyZWFkeSByZWFkIChmb3IgZXhhbXBsZSB0aHJvdWdoICdyZXNwb25zZS5qc29uKCknIG9yICdyZXNwb25zZS50ZXh0KCknKS5cIlxuICAgICk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gIGlmIChyZXMuZGVzdHJveWVkKSB7XG4gICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjYW5jZWwgPSAoZXJyb3IpID0+IHtcbiAgICByZXMub2ZmKFwiY2xvc2VcIiwgY2FuY2VsKTtcbiAgICByZXMub2ZmKFwiZXJyb3JcIiwgY2FuY2VsKTtcbiAgICByZWFkZXIuY2FuY2VsKGVycm9yKS5jYXRjaCgoKSA9PiB7XG4gICAgfSk7XG4gICAgaWYgKGVycm9yKSByZXMuZGVzdHJveShlcnJvcik7XG4gIH07XG4gIHJlcy5vbihcImNsb3NlXCIsIGNhbmNlbCk7XG4gIHJlcy5vbihcImVycm9yXCIsIGNhbmNlbCk7XG4gIG5leHQoKTtcbiAgYXN5bmMgZnVuY3Rpb24gbmV4dCgpIHtcbiAgICB0cnkge1xuICAgICAgZm9yICg7IDsgKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKSBicmVhaztcbiAgICAgICAgaWYgKCFyZXMud3JpdGUodmFsdWUpKSB7XG4gICAgICAgICAgcmVzLm9uY2UoXCJkcmFpblwiLCBuZXh0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlcy5lbmQoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY2FuY2VsKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKSk7XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9hZGFwdGVyL25vZGUudHNcbmZ1bmN0aW9uIHRvTm9kZUhhbmRsZXIoaGFuZGxlcikge1xuICByZXR1cm4gYXN5bmMgKHJlcSwgcmVzKSA9PiB7XG4gICAgY29uc3QgcHJvdG9jb2wgPSByZXEuaGVhZGVyc1tcIngtZm9yd2FyZGVkLXByb3RvXCJdIHx8IChyZXEuc29ja2V0LmVuY3J5cHRlZCA/IFwiaHR0cHNcIiA6IFwiaHR0cFwiKTtcbiAgICBjb25zdCBiYXNlID0gYCR7cHJvdG9jb2x9Oi8vJHtyZXEuaGVhZGVyc1tcIjphdXRob3JpdHlcIl0gfHwgcmVxLmhlYWRlcnMuaG9zdH1gO1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaGFuZGxlcihnZXRSZXF1ZXN0KHsgYmFzZSwgcmVxdWVzdDogcmVxIH0pKTtcbiAgICBzZXRSZXNwb25zZShyZXMsIHJlc3BvbnNlKTtcbiAgfTtcbn1cbmV4cG9ydCB7XG4gIEFQSUVycm9yLFxuICBjcmVhdGVFbmRwb2ludCxcbiAgY3JlYXRlRW5kcG9pbnRDcmVhdG9yLFxuICBjcmVhdGVNaWRkbGV3YXJlLFxuICBjcmVhdGVNaWRkbGV3YXJlQ3JlYXRvcixcbiAgY3JlYXRlUm91dGVyLFxuICBnZXRCb2R5LFxuICBnZXRDb29raWUsXG4gIGdldFJlcXVlc3QsXG4gIGdldFNpZ25lZENvb2tpZSxcbiAganNvbixcbiAgcGFyc2UsXG4gIHBhcnNlU2lnbmVkLFxuICBzZXJpYWxpemUsXG4gIHNlcmlhbGl6ZVNpZ25lZCxcbiAgc2V0Q29va2llLFxuICBzZXRSZXNwb25zZSxcbiAgc2V0U2lnbmVkQ29va2llLFxuICBzaG91bGRTZXJpYWxpemUsXG4gIHNpZ25Db29raWVWYWx1ZSxcbiAgc3RhdHVzQ29kZSxcbiAgdG9Ob2RlSGFuZGxlclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/.pnpm/better-call@0.3.3/node_modules/better-call/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/better-call@0.3.3/node_modules/better-call/dist/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/.pnpm/better-call@0.3.3/node_modules/better-call/dist/index.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIError: () => (/* binding */ APIError),\n/* harmony export */   createEndpoint: () => (/* binding */ createEndpoint),\n/* harmony export */   createEndpointCreator: () => (/* binding */ createEndpointCreator),\n/* harmony export */   createMiddleware: () => (/* binding */ createMiddleware),\n/* harmony export */   createMiddlewareCreator: () => (/* binding */ createMiddlewareCreator),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   getBody: () => (/* binding */ getBody),\n/* harmony export */   getCookie: () => (/* binding */ getCookie),\n/* harmony export */   getRequest: () => (/* binding */ getRequest),\n/* harmony export */   getSignedCookie: () => (/* binding */ getSignedCookie),\n/* harmony export */   json: () => (/* binding */ json),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parseSigned: () => (/* binding */ parseSigned),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   serializeSigned: () => (/* binding */ serializeSigned),\n/* harmony export */   setCookie: () => (/* binding */ setCookie),\n/* harmony export */   setResponse: () => (/* binding */ setResponse),\n/* harmony export */   setSignedCookie: () => (/* binding */ setSignedCookie),\n/* harmony export */   shouldSerialize: () => (/* binding */ shouldSerialize),\n/* harmony export */   signCookieValue: () => (/* binding */ signCookieValue),\n/* harmony export */   statusCode: () => (/* binding */ statusCode),\n/* harmony export */   toNodeHandler: () => (/* binding */ toNodeHandler)\n/* harmony export */ });\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/.pnpm/zod@3.25.64/node_modules/zod/dist/esm/index.js\");\n/* harmony import */ var uncrypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! uncrypto */ \"(rsc)/./node_modules/.pnpm/uncrypto@0.1.3/node_modules/uncrypto/dist/crypto.node.mjs\");\n/* harmony import */ var rou3__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! rou3 */ \"(rsc)/./node_modules/.pnpm/rou3@0.5.1/node_modules/rou3/dist/index.mjs\");\nvar __create = Object.create;\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __getProtoOf = Object.getPrototypeOf;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n  // If the importer is in node compatibility mode or this is not an ESM\n  // file that has been converted to a CommonJS file using a Babel-\n  // compatible transform (i.e. \"__esModule\" has not been set), then set\n  // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n  isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n  mod\n));\nvar __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n\n// node_modules/set-cookie-parser/lib/set-cookie.js\nvar require_set_cookie = __commonJS({\n  \"node_modules/set-cookie-parser/lib/set-cookie.js\"(exports, module) {\n    \"use strict\";\n    var defaultParseOptions = {\n      decodeValues: true,\n      map: false,\n      silent: false\n    };\n    function isNonEmptyString(str) {\n      return typeof str === \"string\" && !!str.trim();\n    }\n    function parseString(setCookieValue, options) {\n      var parts = setCookieValue.split(\";\").filter(isNonEmptyString);\n      var nameValuePairStr = parts.shift();\n      var parsed = parseNameValuePair(nameValuePairStr);\n      var name = parsed.name;\n      var value = parsed.value;\n      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;\n      try {\n        value = options.decodeValues ? decodeURIComponent(value) : value;\n      } catch (e) {\n        console.error(\n          \"set-cookie-parser encountered an error while decoding a cookie with value '\" + value + \"'. Set options.decodeValues to false to disable this feature.\",\n          e\n        );\n      }\n      var cookie = {\n        name,\n        value\n      };\n      parts.forEach(function(part) {\n        var sides = part.split(\"=\");\n        var key = sides.shift().trimLeft().toLowerCase();\n        var value2 = sides.join(\"=\");\n        if (key === \"expires\") {\n          cookie.expires = new Date(value2);\n        } else if (key === \"max-age\") {\n          cookie.maxAge = parseInt(value2, 10);\n        } else if (key === \"secure\") {\n          cookie.secure = true;\n        } else if (key === \"httponly\") {\n          cookie.httpOnly = true;\n        } else if (key === \"samesite\") {\n          cookie.sameSite = value2;\n        } else if (key === \"partitioned\") {\n          cookie.partitioned = true;\n        } else {\n          cookie[key] = value2;\n        }\n      });\n      return cookie;\n    }\n    function parseNameValuePair(nameValuePairStr) {\n      var name = \"\";\n      var value = \"\";\n      var nameValueArr = nameValuePairStr.split(\"=\");\n      if (nameValueArr.length > 1) {\n        name = nameValueArr.shift();\n        value = nameValueArr.join(\"=\");\n      } else {\n        value = nameValuePairStr;\n      }\n      return { name, value };\n    }\n    function parse2(input, options) {\n      options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;\n      if (!input) {\n        if (!options.map) {\n          return [];\n        } else {\n          return {};\n        }\n      }\n      if (input.headers) {\n        if (typeof input.headers.getSetCookie === \"function\") {\n          input = input.headers.getSetCookie();\n        } else if (input.headers[\"set-cookie\"]) {\n          input = input.headers[\"set-cookie\"];\n        } else {\n          var sch = input.headers[Object.keys(input.headers).find(function(key) {\n            return key.toLowerCase() === \"set-cookie\";\n          })];\n          if (!sch && input.headers.cookie && !options.silent) {\n            console.warn(\n              \"Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.\"\n            );\n          }\n          input = sch;\n        }\n      }\n      if (!Array.isArray(input)) {\n        input = [input];\n      }\n      if (!options.map) {\n        return input.filter(isNonEmptyString).map(function(str) {\n          return parseString(str, options);\n        });\n      } else {\n        var cookies = {};\n        return input.filter(isNonEmptyString).reduce(function(cookies2, str) {\n          var cookie = parseString(str, options);\n          cookies2[cookie.name] = cookie;\n          return cookies2;\n        }, cookies);\n      }\n    }\n    function splitCookiesString2(cookiesString) {\n      if (Array.isArray(cookiesString)) {\n        return cookiesString;\n      }\n      if (typeof cookiesString !== \"string\") {\n        return [];\n      }\n      var cookiesStrings = [];\n      var pos = 0;\n      var start;\n      var ch;\n      var lastComma;\n      var nextStart;\n      var cookiesSeparatorFound;\n      function skipWhitespace() {\n        while (pos < cookiesString.length && /\\s/.test(cookiesString.charAt(pos))) {\n          pos += 1;\n        }\n        return pos < cookiesString.length;\n      }\n      function notSpecialChar() {\n        ch = cookiesString.charAt(pos);\n        return ch !== \"=\" && ch !== \";\" && ch !== \",\";\n      }\n      while (pos < cookiesString.length) {\n        start = pos;\n        cookiesSeparatorFound = false;\n        while (skipWhitespace()) {\n          ch = cookiesString.charAt(pos);\n          if (ch === \",\") {\n            lastComma = pos;\n            pos += 1;\n            skipWhitespace();\n            nextStart = pos;\n            while (pos < cookiesString.length && notSpecialChar()) {\n              pos += 1;\n            }\n            if (pos < cookiesString.length && cookiesString.charAt(pos) === \"=\") {\n              cookiesSeparatorFound = true;\n              pos = nextStart;\n              cookiesStrings.push(cookiesString.substring(start, lastComma));\n              start = pos;\n            } else {\n              pos = lastComma + 1;\n            }\n          } else {\n            pos += 1;\n          }\n        }\n        if (!cookiesSeparatorFound || pos >= cookiesString.length) {\n          cookiesStrings.push(cookiesString.substring(start, cookiesString.length));\n        }\n      }\n      return cookiesStrings;\n    }\n    module.exports = parse2;\n    module.exports.parse = parse2;\n    module.exports.parseString = parseString;\n    module.exports.splitCookiesString = splitCookiesString2;\n  }\n});\n\n// src/endpoint.ts\n\n\n// src/error.ts\nvar APIError = class extends Error {\n  constructor(status, body, headers) {\n    super(`API Error: ${status} ${body?.message ?? \"\"}`, {\n      cause: body\n    });\n    __publicField(this, \"status\");\n    __publicField(this, \"headers\");\n    __publicField(this, \"body\");\n    this.status = status;\n    this.body = body ?? {};\n    this.body.code = body?.message ? body.message.toUpperCase().replace(/ /g, \"_\").replace(/[^A-Z0-9_]/g, \"\") : status;\n    this.stack = \"\";\n    this.headers = headers ?? new Headers();\n    if (!this.headers.has(\"Content-Type\")) {\n      this.headers.set(\"Content-Type\", \"application/json\");\n    }\n    this.name = \"BetterCallAPIError\";\n  }\n};\n\n// src/helper.ts\nvar json = (body, option) => {\n  return {\n    response: {\n      body: option?.body ?? body,\n      status: option?.status ?? 200,\n      statusText: option?.statusText ?? \"OK\",\n      headers: option?.headers\n    },\n    body,\n    _flag: \"json\"\n  };\n};\n\n// src/cookie.ts\n\nvar algorithm = { name: \"HMAC\", hash: \"SHA-256\" };\nvar getCryptoKey = async (secret) => {\n  const secretBuf = typeof secret === \"string\" ? new TextEncoder().encode(secret) : secret;\n  return await uncrypto__WEBPACK_IMPORTED_MODULE_1__.subtle.importKey(\"raw\", secretBuf, algorithm, false, [\"sign\", \"verify\"]);\n};\nvar makeSignature = async (value, secret) => {\n  const key = await getCryptoKey(secret);\n  const signature = await uncrypto__WEBPACK_IMPORTED_MODULE_1__.subtle.sign(algorithm.name, key, new TextEncoder().encode(value));\n  return btoa(String.fromCharCode(...new Uint8Array(signature)));\n};\nvar verifySignature = async (base64Signature, value, secret) => {\n  try {\n    const signatureBinStr = atob(base64Signature);\n    const signature = new Uint8Array(signatureBinStr.length);\n    for (let i = 0, len = signatureBinStr.length; i < len; i++) {\n      signature[i] = signatureBinStr.charCodeAt(i);\n    }\n    return await uncrypto__WEBPACK_IMPORTED_MODULE_1__.subtle.verify(algorithm, secret, signature, new TextEncoder().encode(value));\n  } catch (e) {\n    return false;\n  }\n};\nvar validCookieNameRegEx = /^[\\w!#$%&'*.^`|~+-]+$/;\nvar validCookieValueRegEx = /^[ !#-:<-[\\]-~]*$/;\nvar parse = (cookie, name) => {\n  const pairs = cookie.trim().split(\";\");\n  return pairs.reduce((parsedCookie, pairStr) => {\n    pairStr = pairStr.trim();\n    const valueStartPos = pairStr.indexOf(\"=\");\n    if (valueStartPos === -1) {\n      return parsedCookie;\n    }\n    const cookieName = pairStr.substring(0, valueStartPos).trim();\n    if (name && name !== cookieName || !validCookieNameRegEx.test(cookieName)) {\n      return parsedCookie;\n    }\n    let cookieValue = pairStr.substring(valueStartPos + 1).trim();\n    if (cookieValue.startsWith('\"') && cookieValue.endsWith('\"')) {\n      cookieValue = cookieValue.slice(1, -1);\n    }\n    if (validCookieValueRegEx.test(cookieValue)) {\n      parsedCookie[cookieName] = decodeURIComponent(cookieValue);\n    }\n    return parsedCookie;\n  }, {});\n};\nvar parseSigned = async (cookie, secret, name) => {\n  const parsedCookie = {};\n  const secretKey = await getCryptoKey(secret);\n  for (const [key, value] of Object.entries(parse(cookie, name))) {\n    const signatureStartPos = value.lastIndexOf(\".\");\n    if (signatureStartPos < 1) {\n      continue;\n    }\n    const signedValue = value.substring(0, signatureStartPos);\n    const signature = value.substring(signatureStartPos + 1);\n    if (signature.length !== 44 || !signature.endsWith(\"=\")) {\n      continue;\n    }\n    const isVerified = await verifySignature(signature, signedValue, secretKey);\n    parsedCookie[key] = isVerified ? signedValue : false;\n  }\n  return parsedCookie;\n};\nvar _serialize = (name, value, opt = {}) => {\n  let cookie = `${name}=${value}`;\n  if (name.startsWith(\"__Secure-\") && !opt.secure) {\n    opt.secure = true;\n  }\n  if (name.startsWith(\"__Host-\")) {\n    if (!opt.secure) {\n      opt.secure = true;\n    }\n    if (opt.path !== \"/\") {\n      opt.path = \"/\";\n    }\n    if (opt.domain) {\n      opt.domain = void 0;\n    }\n  }\n  if (opt && typeof opt.maxAge === \"number\" && opt.maxAge >= 0) {\n    if (opt.maxAge > 3456e4) {\n      throw new Error(\n        \"Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.\"\n      );\n    }\n    cookie += `; Max-Age=${Math.floor(opt.maxAge)}`;\n  }\n  if (opt.domain && opt.prefix !== \"host\") {\n    cookie += `; Domain=${opt.domain}`;\n  }\n  if (opt.path) {\n    cookie += `; Path=${opt.path}`;\n  }\n  if (opt.expires) {\n    if (opt.expires.getTime() - Date.now() > 3456e7) {\n      throw new Error(\n        \"Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.\"\n      );\n    }\n    cookie += `; Expires=${opt.expires.toUTCString()}`;\n  }\n  if (opt.httpOnly) {\n    cookie += \"; HttpOnly\";\n  }\n  if (opt.secure) {\n    cookie += \"; Secure\";\n  }\n  if (opt.sameSite) {\n    cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;\n  }\n  if (opt.partitioned) {\n    if (!opt.secure) {\n      throw new Error(\"Partitioned Cookie must have Secure attributes\");\n    }\n    cookie += \"; Partitioned\";\n  }\n  return cookie;\n};\nvar serialize = (name, value, opt) => {\n  value = encodeURIComponent(value);\n  return _serialize(name, value, opt);\n};\nvar serializeSigned = async (name, value, secret, opt = {}) => {\n  const signature = await makeSignature(value, secret);\n  value = `${value}.${signature}`;\n  value = encodeURIComponent(value);\n  return _serialize(name, value, opt);\n};\nvar signCookieValue = async (value, secret) => {\n  const signature = await makeSignature(value, secret);\n  value = `${value}.${signature}`;\n  value = encodeURIComponent(value);\n  return value;\n};\n\n// src/cookie-utils.ts\nvar getCookie = (cookie, key, prefix) => {\n  if (!cookie) {\n    return void 0;\n  }\n  let finalKey = key;\n  if (prefix) {\n    if (prefix === \"secure\") {\n      finalKey = \"__Secure-\" + key;\n    } else if (prefix === \"host\") {\n      finalKey = \"__Host-\" + key;\n    } else {\n      return void 0;\n    }\n  }\n  const obj = parse(cookie, finalKey);\n  return obj[finalKey];\n};\nvar setCookie = (header, name, value, opt) => {\n  const existingCookies = header.get(\"Set-Cookie\");\n  if (existingCookies) {\n    const cookies = existingCookies.split(\", \");\n    const updatedCookies = cookies.filter((cookie2) => !cookie2.startsWith(`${name}=`));\n    header.delete(\"Set-Cookie\");\n    updatedCookies.forEach((cookie2) => header.append(\"Set-Cookie\", cookie2));\n  }\n  let cookie;\n  if (opt?.prefix === \"secure\") {\n    cookie = serialize(\"__Secure-\" + name, value, { path: \"/\", ...opt, secure: true });\n  } else if (opt?.prefix === \"host\") {\n    cookie = serialize(\"__Host-\" + name, value, {\n      ...opt,\n      path: \"/\",\n      secure: true,\n      domain: void 0\n    });\n  } else {\n    cookie = serialize(name, value, { path: \"/\", ...opt });\n  }\n  header.append(\"Set-Cookie\", cookie);\n};\nvar setSignedCookie = async (header, name, value, secret, opt) => {\n  let cookie;\n  if (opt?.prefix === \"secure\") {\n    cookie = await serializeSigned(\"__Secure-\" + name, value, secret, {\n      path: \"/\",\n      ...opt,\n      secure: true\n    });\n  } else if (opt?.prefix === \"host\") {\n    cookie = await serializeSigned(\"__Host-\" + name, value, secret, {\n      ...opt,\n      path: \"/\",\n      secure: true,\n      domain: void 0\n    });\n  } else {\n    cookie = await serializeSigned(name, value, secret, { path: \"/\", ...opt });\n  }\n  header.append(\"Set-Cookie\", cookie);\n};\nvar getSignedCookie = async (header, secret, key, prefix) => {\n  const cookie = header.get(\"cookie\");\n  if (!cookie) {\n    return void 0;\n  }\n  let finalKey = key;\n  if (prefix) {\n    if (prefix === \"secure\") {\n      finalKey = \"__Secure-\" + key;\n    } else if (prefix === \"host\") {\n      finalKey = \"__Host-\" + key;\n    }\n  }\n  const obj = await parseSigned(cookie, secret, finalKey);\n  return obj[finalKey];\n};\n\n// src/endpoint.ts\nfunction createEndpointCreator(opts) {\n  return (path, options, handler) => {\n    return createEndpoint(\n      path,\n      {\n        ...options,\n        use: [...options?.use || [], ...opts?.use || []]\n      },\n      handler\n    );\n  };\n}\nfunction createEndpoint(path, options, handler) {\n  let responseHeader = new Headers();\n  const handle = async (...ctx) => {\n    let internalCtx = {\n      setHeader(key, value) {\n        responseHeader.set(key, value);\n      },\n      setCookie(key, value, options2) {\n        setCookie(responseHeader, key, value, options2);\n      },\n      getCookie(key, prefix) {\n        const header = ctx[0]?.headers;\n        const cookieH = header?.get(\"cookie\");\n        const cookie = getCookie(cookieH || \"\", key, prefix);\n        return cookie;\n      },\n      getSignedCookie(key, secret, prefix) {\n        const header = ctx[0]?.headers;\n        if (!header) {\n          throw new TypeError(\"Headers are required\");\n        }\n        const cookie = getSignedCookie(header, secret, key, prefix);\n        return cookie;\n      },\n      async setSignedCookie(key, value, secret, options2) {\n        await setSignedCookie(responseHeader, key, value, secret, options2);\n      },\n      redirect(url) {\n        responseHeader.set(\"Location\", url);\n        return new APIError(\"FOUND\");\n      },\n      json,\n      context: ctx[0]?.context || {},\n      _flag: ctx[0]?.asResponse ? \"router\" : ctx[0]?._flag,\n      responseHeader,\n      path,\n      ...ctx[0] || {}\n    };\n    if (options.use?.length) {\n      let middlewareContexts = {};\n      let middlewareBody = {};\n      for (const middleware of options.use) {\n        if (typeof middleware !== \"function\") {\n          console.warn(\"Middleware is not a function\", {\n            middleware\n          });\n          continue;\n        }\n        const res = await middleware(internalCtx);\n        if (res) {\n          const body = res.options?.body ? res.options.body.parse(internalCtx.body) : void 0;\n          middlewareContexts = {\n            ...middlewareContexts,\n            ...res\n          };\n          middlewareBody = {\n            ...middlewareBody,\n            ...body\n          };\n        }\n      }\n      internalCtx = {\n        ...internalCtx,\n        body: {\n          ...middlewareBody,\n          ...internalCtx.body\n        },\n        context: {\n          ...internalCtx.context || {},\n          ...middlewareContexts\n        }\n      };\n    }\n    try {\n      const body = options.body ? options.body.parse(internalCtx.body) : internalCtx.body;\n      internalCtx = {\n        ...internalCtx,\n        body: body ? {\n          ...body,\n          ...internalCtx.body\n        } : internalCtx.body\n      };\n      internalCtx.query = options.query ? options.query.parse(internalCtx.query) : internalCtx.query;\n    } catch (e) {\n      if (e instanceof zod__WEBPACK_IMPORTED_MODULE_0__.ZodError) {\n        throw new APIError(\"BAD_REQUEST\", {\n          message: e.message,\n          details: e.errors\n        });\n      }\n      throw e;\n    }\n    if (options.requireHeaders && !internalCtx.headers) {\n      throw new APIError(\"BAD_REQUEST\", {\n        message: \"Headers are required\"\n      });\n    }\n    if (options.requireRequest && !internalCtx.request) {\n      throw new APIError(\"BAD_REQUEST\", {\n        message: \"Request is required\"\n      });\n    }\n    if (internalCtx.request && !internalCtx.headers) {\n      internalCtx.headers = internalCtx.request.headers;\n    }\n    try {\n      let res = await handler(internalCtx);\n      let actualResponse = res;\n      if (res && typeof res === \"object\" && \"_flag\" in res) {\n        if (res._flag === \"json\" && internalCtx._flag === \"router\") {\n          const h = res.response.headers;\n          Object.keys(h || {}).forEach((key) => {\n            responseHeader.set(key, h[key]);\n          });\n          responseHeader.set(\"Content-Type\", \"application/json\");\n          actualResponse = new Response(JSON.stringify(res.response.body), {\n            status: res.response.status ?? 200,\n            statusText: res.response.statusText,\n            headers: responseHeader\n          });\n        } else {\n          actualResponse = res.body;\n        }\n      }\n      responseHeader = new Headers();\n      return actualResponse;\n    } catch (e) {\n      if (e instanceof APIError) {\n        responseHeader.set(\"Content-Type\", \"application/json\");\n        e.headers = responseHeader;\n        responseHeader = new Headers();\n        throw e;\n      }\n      throw e;\n    }\n  };\n  handle.path = path;\n  handle.options = options;\n  handle.method = options.method;\n  handle.headers = responseHeader;\n  return handle;\n}\n\n// src/router.ts\n\n\n// src/utils.ts\nasync function getBody(request) {\n  const contentType = request.headers.get(\"content-type\") || \"\";\n  if (!request.body) {\n    return void 0;\n  }\n  if (contentType.includes(\"application/json\")) {\n    return await request.json();\n  }\n  if (contentType.includes(\"application/x-www-form-urlencoded\")) {\n    const formData = await request.formData();\n    const result = {};\n    formData.forEach((value, key) => {\n      result[key] = value.toString();\n    });\n    return result;\n  }\n  if (contentType.includes(\"multipart/form-data\")) {\n    const formData = await request.formData();\n    const result = {};\n    formData.forEach((value, key) => {\n      result[key] = value;\n    });\n    return result;\n  }\n  if (contentType.includes(\"text/plain\")) {\n    return await request.text();\n  }\n  if (contentType.includes(\"application/octet-stream\")) {\n    return await request.arrayBuffer();\n  }\n  if (contentType.includes(\"application/pdf\") || contentType.includes(\"image/\") || contentType.includes(\"video/\")) {\n    const blob = await request.blob();\n    return blob;\n  }\n  if (contentType.includes(\"application/stream\") || request.body instanceof ReadableStream) {\n    return request.body;\n  }\n  return await request.text();\n}\nfunction shouldSerialize(body) {\n  return typeof body === \"object\" && body !== null && !(body instanceof Blob) && !(body instanceof FormData);\n}\nvar statusCode = {\n  OK: 200,\n  CREATED: 201,\n  ACCEPTED: 202,\n  NO_CONTENT: 204,\n  MULTIPLE_CHOICES: 300,\n  MOVED_PERMANENTLY: 301,\n  FOUND: 302,\n  SEE_OTHER: 303,\n  NOT_MODIFIED: 304,\n  TEMPORARY_REDIRECT: 307,\n  BAD_REQUEST: 400,\n  UNAUTHORIZED: 401,\n  PAYMENT_REQUIRED: 402,\n  FORBIDDEN: 403,\n  NOT_FOUND: 404,\n  METHOD_NOT_ALLOWED: 405,\n  NOT_ACCEPTABLE: 406,\n  PROXY_AUTHENTICATION_REQUIRED: 407,\n  REQUEST_TIMEOUT: 408,\n  CONFLICT: 409,\n  GONE: 410,\n  LENGTH_REQUIRED: 411,\n  PRECONDITION_FAILED: 412,\n  PAYLOAD_TOO_LARGE: 413,\n  URI_TOO_LONG: 414,\n  UNSUPPORTED_MEDIA_TYPE: 415,\n  RANGE_NOT_SATISFIABLE: 416,\n  EXPECTATION_FAILED: 417,\n  \"I'M_A_TEAPOT\": 418,\n  MISDIRECTED_REQUEST: 421,\n  UNPROCESSABLE_ENTITY: 422,\n  LOCKED: 423,\n  FAILED_DEPENDENCY: 424,\n  TOO_EARLY: 425,\n  UPGRADE_REQUIRED: 426,\n  PRECONDITION_REQUIRED: 428,\n  TOO_MANY_REQUESTS: 429,\n  REQUEST_HEADER_FIELDS_TOO_LARGE: 431,\n  UNAVAILABLE_FOR_LEGAL_REASONS: 451,\n  INTERNAL_SERVER_ERROR: 500,\n  NOT_IMPLEMENTED: 501,\n  BAD_GATEWAY: 502,\n  SERVICE_UNAVAILABLE: 503,\n  GATEWAY_TIMEOUT: 504,\n  HTTP_VERSION_NOT_SUPPORTED: 505,\n  VARIANT_ALSO_NEGOTIATES: 506,\n  INSUFFICIENT_STORAGE: 507,\n  LOOP_DETECTED: 508,\n  NOT_EXTENDED: 510,\n  NETWORK_AUTHENTICATION_REQUIRED: 511\n};\n\n// src/router.ts\nvar createRouter = (endpoints, config) => {\n  const _endpoints = Object.values(endpoints);\n  const router = (0,rou3__WEBPACK_IMPORTED_MODULE_2__.createRouter)();\n  for (const endpoint of _endpoints) {\n    if (endpoint.options.metadata?.SERVER_ONLY) continue;\n    if (Array.isArray(endpoint.options?.method)) {\n      for (const method of endpoint.options.method) {\n        (0,rou3__WEBPACK_IMPORTED_MODULE_2__.addRoute)(router, method, endpoint.path, endpoint);\n      }\n    } else {\n      (0,rou3__WEBPACK_IMPORTED_MODULE_2__.addRoute)(router, endpoint.options.method, endpoint.path, endpoint);\n    }\n  }\n  const middlewareRouter = (0,rou3__WEBPACK_IMPORTED_MODULE_2__.createRouter)();\n  for (const route of config?.routerMiddleware || []) {\n    (0,rou3__WEBPACK_IMPORTED_MODULE_2__.addRoute)(middlewareRouter, \"*\", route.path, route.middleware);\n  }\n  const handler = async (request) => {\n    const url = new URL(request.url);\n    let path = url.pathname;\n    if (config?.basePath) {\n      path = path.split(config.basePath)[1];\n    }\n    if (!path?.length) {\n      config?.onError?.(new APIError(\"NOT_FOUND\"));\n      console.warn(\n        `[better-call]: Make sure the URL has the basePath (${config?.basePath}).`\n      );\n      return new Response(null, {\n        status: 404,\n        statusText: \"Not Found\"\n      });\n    }\n    const method = request.method;\n    const route = (0,rou3__WEBPACK_IMPORTED_MODULE_2__.findRoute)(router, method, path);\n    const handler2 = route?.data;\n    const body = await getBody(request);\n    const headers = request.headers;\n    const query = Object.fromEntries(url.searchParams);\n    const routerMiddleware = (0,rou3__WEBPACK_IMPORTED_MODULE_2__.findAllRoutes)(middlewareRouter, \"*\", path);\n    if (!handler2) {\n      return new Response(null, {\n        status: 404,\n        statusText: \"Not Found\"\n      });\n    }\n    try {\n      let middlewareContext = {};\n      if (routerMiddleware?.length) {\n        for (const route2 of routerMiddleware) {\n          const middleware = route2.data;\n          const res = await middleware({\n            path,\n            method,\n            headers,\n            params: route2?.params,\n            request,\n            body,\n            query,\n            context: {\n              ...config?.extraContext\n            }\n          });\n          if (res instanceof Response) {\n            return res;\n          }\n          if (res?._flag === \"json\") {\n            return new Response(JSON.stringify(res), {\n              headers: res.headers\n            });\n          }\n          if (res) {\n            middlewareContext = {\n              ...res,\n              ...middlewareContext\n            };\n          }\n        }\n      }\n      const handlerRes = await handler2({\n        path,\n        method,\n        headers,\n        params: route?.params,\n        request,\n        body,\n        query,\n        _flag: \"router\",\n        context: {\n          ...middlewareContext,\n          ...config?.extraContext\n        }\n      });\n      if (handlerRes instanceof Response) {\n        return handlerRes;\n      }\n      const resBody = shouldSerialize(handlerRes) ? JSON.stringify(handlerRes) : handlerRes;\n      return new Response(resBody, {\n        headers: handler2.headers\n      });\n    } catch (e) {\n      if (config?.onError) {\n        const onErrorRes = await config.onError(e);\n        if (onErrorRes instanceof Response) {\n          return onErrorRes;\n        }\n      }\n      if (e instanceof APIError) {\n        return new Response(e.body ? JSON.stringify(e.body) : null, {\n          status: statusCode[e.status],\n          statusText: e.status,\n          headers: e.headers\n        });\n      }\n      if (config?.throwError) {\n        throw e;\n      }\n      return new Response(null, {\n        status: 500,\n        statusText: \"Internal Server Error\"\n      });\n    }\n  };\n  return {\n    handler: async (request) => {\n      const onReq = await config?.onRequest?.(request);\n      if (onReq instanceof Response) {\n        return onReq;\n      }\n      const req = onReq instanceof Request ? onReq : request;\n      const res = await handler(req);\n      const onRes = await config?.onResponse?.(res);\n      if (onRes instanceof Response) {\n        return onRes;\n      }\n      return res;\n    },\n    endpoints\n  };\n};\n\n// src/middleware.ts\nfunction createMiddleware(optionsOrHandler, handler) {\n  if (typeof optionsOrHandler === \"function\") {\n    return createEndpoint(\n      \"*\",\n      {\n        method: \"*\"\n      },\n      optionsOrHandler\n    );\n  }\n  if (!handler) {\n    throw new Error(\"Middleware handler is required\");\n  }\n  const endpoint = createEndpoint(\n    \"*\",\n    {\n      ...optionsOrHandler,\n      method: \"*\"\n    },\n    handler\n  );\n  return endpoint;\n}\nvar createMiddlewareCreator = (opts) => {\n  function fn(optionsOrHandler, handler) {\n    if (typeof optionsOrHandler === \"function\") {\n      return createEndpoint(\n        \"*\",\n        {\n          method: \"*\"\n        },\n        optionsOrHandler\n      );\n    }\n    if (!handler) {\n      throw new Error(\"Middleware handler is required\");\n    }\n    const endpoint = createEndpoint(\n      \"*\",\n      {\n        ...optionsOrHandler,\n        method: \"*\"\n      },\n      handler\n    );\n    return endpoint;\n  }\n  return fn;\n};\n\n// src/types.ts\n\n\n// src/adapter/request.ts\nvar set_cookie_parser = __toESM(require_set_cookie(), 1);\nfunction get_raw_body(req, body_size_limit) {\n  const h = req.headers;\n  if (!h[\"content-type\"]) return null;\n  const content_length = Number(h[\"content-length\"]);\n  if (req.httpVersionMajor === 1 && isNaN(content_length) && h[\"transfer-encoding\"] == null || content_length === 0) {\n    return null;\n  }\n  let length = content_length;\n  if (body_size_limit) {\n    if (!length) {\n      length = body_size_limit;\n    } else if (length > body_size_limit) {\n      throw Error(\n        `Received content-length of ${length}, but only accept up to ${body_size_limit} bytes.`\n      );\n    }\n  }\n  if (req.destroyed) {\n    const readable = new ReadableStream();\n    readable.cancel();\n    return readable;\n  }\n  let size = 0;\n  let cancelled = false;\n  return new ReadableStream({\n    start(controller) {\n      req.on(\"error\", (error) => {\n        cancelled = true;\n        controller.error(error);\n      });\n      req.on(\"end\", () => {\n        if (cancelled) return;\n        controller.close();\n      });\n      req.on(\"data\", (chunk) => {\n        if (cancelled) return;\n        size += chunk.length;\n        if (size > length) {\n          cancelled = true;\n          controller.error(\n            new Error(\n              `request body size exceeded ${content_length ? \"'content-length'\" : \"BODY_SIZE_LIMIT\"} of ${length}`\n            )\n          );\n          return;\n        }\n        controller.enqueue(chunk);\n        if (controller.desiredSize === null || controller.desiredSize <= 0) {\n          req.pause();\n        }\n      });\n    },\n    pull() {\n      req.resume();\n    },\n    cancel(reason) {\n      cancelled = true;\n      req.destroy(reason);\n    }\n  });\n}\nfunction getRequest({\n  request,\n  base,\n  bodySizeLimit\n}) {\n  return new Request(base + request.url, {\n    // @ts-expect-error\n    duplex: \"half\",\n    method: request.method,\n    body: get_raw_body(request, bodySizeLimit),\n    headers: request.headers\n  });\n}\nasync function setResponse(res, response) {\n  for (const [key, value] of response.headers) {\n    try {\n      res.setHeader(\n        key,\n        key === \"set-cookie\" ? set_cookie_parser.splitCookiesString(response.headers.get(key)) : value\n      );\n    } catch (error) {\n      res.getHeaderNames().forEach((name) => res.removeHeader(name));\n      res.writeHead(500).end(String(error));\n      return;\n    }\n  }\n  res.writeHead(response.status);\n  if (!response.body) {\n    res.end();\n    return;\n  }\n  if (response.body.locked) {\n    res.end(\n      \"Fatal error: Response body is locked. This can happen when the response was already read (for example through 'response.json()' or 'response.text()').\"\n    );\n    return;\n  }\n  const reader = response.body.getReader();\n  if (res.destroyed) {\n    reader.cancel();\n    return;\n  }\n  const cancel = (error) => {\n    res.off(\"close\", cancel);\n    res.off(\"error\", cancel);\n    reader.cancel(error).catch(() => {\n    });\n    if (error) res.destroy(error);\n  };\n  res.on(\"close\", cancel);\n  res.on(\"error\", cancel);\n  next();\n  async function next() {\n    try {\n      for (; ; ) {\n        const { done, value } = await reader.read();\n        if (done) break;\n        if (!res.write(value)) {\n          res.once(\"drain\", next);\n          return;\n        }\n      }\n      res.end();\n    } catch (error) {\n      cancel(error instanceof Error ? error : new Error(String(error)));\n    }\n  }\n}\n\n// src/adapter/node.ts\nfunction toNodeHandler(handler) {\n  return async (req, res) => {\n    const protocol = req.headers[\"x-forwarded-proto\"] || (req.socket.encrypted ? \"https\" : \"http\");\n    const base = `${protocol}://${req.headers[\":authority\"] || req.headers.host}`;\n    const response = await handler(getRequest({ base, request: req }));\n    setResponse(res, response);\n  };\n}\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vYmV0dGVyLWNhbGxAMC4zLjMvbm9kZV9tb2R1bGVzL2JldHRlci1jYWxsL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw2REFBNkQ7QUFDM0k7QUFDQSwyREFBMkQsYUFBYTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDRGQUE0RjtBQUN6SDtBQUNBO0FBQ0E7QUFDQSxtR0FBbUc7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsOEJBQThCO0FBQ3ZHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSx3TUFBd00sY0FBYztBQUN0TjtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQzRGOztBQUU1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0RBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4Q0FBUTtBQUNoQjtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUyxLQUFLLDhDQUE4QztBQUNoRixnREFBZ0Qsb0JBQW9CO0FBQ3BFO0FBQ0E7QUFDQTtBQXdCRTtBQUNGIiwic291cmNlcyI6WyIvVXNlcnMvZ29tb2xlbW9rZ2F0aXRzb2UvcHJvamVjdHMvZW1haWwtcHJldmlld2VyLWFwcGxpY2F0aW9uL25vZGVfbW9kdWxlcy8ucG5wbS9iZXR0ZXItY2FsbEAwLjMuMy9ub2RlX21vZHVsZXMvYmV0dGVyLWNhbGwvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jcmVhdGUgPSBPYmplY3QuY3JlYXRlO1xudmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2dldE93blByb3BEZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fZ2V0UHJvdG9PZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcbnZhciBfX2hhc093blByb3AgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIF9fZGVmTm9ybWFsUHJvcCA9IChvYmosIGtleSwgdmFsdWUpID0+IGtleSBpbiBvYmogPyBfX2RlZlByb3Aob2JqLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWUgfSkgOiBvYmpba2V5XSA9IHZhbHVlO1xudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkge1xuICByZXR1cm4gbW9kIHx8ICgwLCBjYltfX2dldE93blByb3BOYW1lcyhjYilbMF1dKSgobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0cztcbn07XG52YXIgX19jb3B5UHJvcHMgPSAodG8sIGZyb20sIGV4Y2VwdCwgZGVzYykgPT4ge1xuICBpZiAoZnJvbSAmJiB0eXBlb2YgZnJvbSA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgZnJvbSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgZm9yIChsZXQga2V5IG9mIF9fZ2V0T3duUHJvcE5hbWVzKGZyb20pKVxuICAgICAgaWYgKCFfX2hhc093blByb3AuY2FsbCh0bywga2V5KSAmJiBrZXkgIT09IGV4Y2VwdClcbiAgICAgICAgX19kZWZQcm9wKHRvLCBrZXksIHsgZ2V0OiAoKSA9PiBmcm9tW2tleV0sIGVudW1lcmFibGU6ICEoZGVzYyA9IF9fZ2V0T3duUHJvcERlc2MoZnJvbSwga2V5KSkgfHwgZGVzYy5lbnVtZXJhYmxlIH0pO1xuICB9XG4gIHJldHVybiB0bztcbn07XG52YXIgX190b0VTTSA9IChtb2QsIGlzTm9kZU1vZGUsIHRhcmdldCkgPT4gKHRhcmdldCA9IG1vZCAhPSBudWxsID8gX19jcmVhdGUoX19nZXRQcm90b09mKG1vZCkpIDoge30sIF9fY29weVByb3BzKFxuICAvLyBJZiB0aGUgaW1wb3J0ZXIgaXMgaW4gbm9kZSBjb21wYXRpYmlsaXR5IG1vZGUgb3IgdGhpcyBpcyBub3QgYW4gRVNNXG4gIC8vIGZpbGUgdGhhdCBoYXMgYmVlbiBjb252ZXJ0ZWQgdG8gYSBDb21tb25KUyBmaWxlIHVzaW5nIGEgQmFiZWwtXG4gIC8vIGNvbXBhdGlibGUgdHJhbnNmb3JtIChpLmUuIFwiX19lc01vZHVsZVwiIGhhcyBub3QgYmVlbiBzZXQpLCB0aGVuIHNldFxuICAvLyBcImRlZmF1bHRcIiB0byB0aGUgQ29tbW9uSlMgXCJtb2R1bGUuZXhwb3J0c1wiIGZvciBub2RlIGNvbXBhdGliaWxpdHkuXG4gIGlzTm9kZU1vZGUgfHwgIW1vZCB8fCAhbW9kLl9fZXNNb2R1bGUgPyBfX2RlZlByb3AodGFyZ2V0LCBcImRlZmF1bHRcIiwgeyB2YWx1ZTogbW9kLCBlbnVtZXJhYmxlOiB0cnVlIH0pIDogdGFyZ2V0LFxuICBtb2RcbikpO1xudmFyIF9fcHVibGljRmllbGQgPSAob2JqLCBrZXksIHZhbHVlKSA9PiBfX2RlZk5vcm1hbFByb3Aob2JqLCB0eXBlb2Yga2V5ICE9PSBcInN5bWJvbFwiID8ga2V5ICsgXCJcIiA6IGtleSwgdmFsdWUpO1xuXG4vLyBub2RlX21vZHVsZXMvc2V0LWNvb2tpZS1wYXJzZXIvbGliL3NldC1jb29raWUuanNcbnZhciByZXF1aXJlX3NldF9jb29raWUgPSBfX2NvbW1vbkpTKHtcbiAgXCJub2RlX21vZHVsZXMvc2V0LWNvb2tpZS1wYXJzZXIvbGliL3NldC1jb29raWUuanNcIihleHBvcnRzLCBtb2R1bGUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgZGVmYXVsdFBhcnNlT3B0aW9ucyA9IHtcbiAgICAgIGRlY29kZVZhbHVlczogdHJ1ZSxcbiAgICAgIG1hcDogZmFsc2UsXG4gICAgICBzaWxlbnQ6IGZhbHNlXG4gICAgfTtcbiAgICBmdW5jdGlvbiBpc05vbkVtcHR5U3RyaW5nKHN0cikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBzdHIgPT09IFwic3RyaW5nXCIgJiYgISFzdHIudHJpbSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZVN0cmluZyhzZXRDb29raWVWYWx1ZSwgb3B0aW9ucykge1xuICAgICAgdmFyIHBhcnRzID0gc2V0Q29va2llVmFsdWUuc3BsaXQoXCI7XCIpLmZpbHRlcihpc05vbkVtcHR5U3RyaW5nKTtcbiAgICAgIHZhciBuYW1lVmFsdWVQYWlyU3RyID0gcGFydHMuc2hpZnQoKTtcbiAgICAgIHZhciBwYXJzZWQgPSBwYXJzZU5hbWVWYWx1ZVBhaXIobmFtZVZhbHVlUGFpclN0cik7XG4gICAgICB2YXIgbmFtZSA9IHBhcnNlZC5uYW1lO1xuICAgICAgdmFyIHZhbHVlID0gcGFyc2VkLnZhbHVlO1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0UGFyc2VPcHRpb25zLCBvcHRpb25zKSA6IGRlZmF1bHRQYXJzZU9wdGlvbnM7XG4gICAgICB0cnkge1xuICAgICAgICB2YWx1ZSA9IG9wdGlvbnMuZGVjb2RlVmFsdWVzID8gZGVjb2RlVVJJQ29tcG9uZW50KHZhbHVlKSA6IHZhbHVlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwic2V0LWNvb2tpZS1wYXJzZXIgZW5jb3VudGVyZWQgYW4gZXJyb3Igd2hpbGUgZGVjb2RpbmcgYSBjb29raWUgd2l0aCB2YWx1ZSAnXCIgKyB2YWx1ZSArIFwiJy4gU2V0IG9wdGlvbnMuZGVjb2RlVmFsdWVzIHRvIGZhbHNlIHRvIGRpc2FibGUgdGhpcyBmZWF0dXJlLlwiLFxuICAgICAgICAgIGVcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb29raWUgPSB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIHZhbHVlXG4gICAgICB9O1xuICAgICAgcGFydHMuZm9yRWFjaChmdW5jdGlvbihwYXJ0KSB7XG4gICAgICAgIHZhciBzaWRlcyA9IHBhcnQuc3BsaXQoXCI9XCIpO1xuICAgICAgICB2YXIga2V5ID0gc2lkZXMuc2hpZnQoKS50cmltTGVmdCgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciB2YWx1ZTIgPSBzaWRlcy5qb2luKFwiPVwiKTtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJleHBpcmVzXCIpIHtcbiAgICAgICAgICBjb29raWUuZXhwaXJlcyA9IG5ldyBEYXRlKHZhbHVlMik7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcIm1heC1hZ2VcIikge1xuICAgICAgICAgIGNvb2tpZS5tYXhBZ2UgPSBwYXJzZUludCh2YWx1ZTIsIDEwKTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwic2VjdXJlXCIpIHtcbiAgICAgICAgICBjb29raWUuc2VjdXJlID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09IFwiaHR0cG9ubHlcIikge1xuICAgICAgICAgIGNvb2tpZS5odHRwT25seSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInNhbWVzaXRlXCIpIHtcbiAgICAgICAgICBjb29raWUuc2FtZVNpdGUgPSB2YWx1ZTI7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSBcInBhcnRpdGlvbmVkXCIpIHtcbiAgICAgICAgICBjb29raWUucGFydGl0aW9uZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvb2tpZVtrZXldID0gdmFsdWUyO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjb29raWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhcnNlTmFtZVZhbHVlUGFpcihuYW1lVmFsdWVQYWlyU3RyKSB7XG4gICAgICB2YXIgbmFtZSA9IFwiXCI7XG4gICAgICB2YXIgdmFsdWUgPSBcIlwiO1xuICAgICAgdmFyIG5hbWVWYWx1ZUFyciA9IG5hbWVWYWx1ZVBhaXJTdHIuc3BsaXQoXCI9XCIpO1xuICAgICAgaWYgKG5hbWVWYWx1ZUFyci5sZW5ndGggPiAxKSB7XG4gICAgICAgIG5hbWUgPSBuYW1lVmFsdWVBcnIuc2hpZnQoKTtcbiAgICAgICAgdmFsdWUgPSBuYW1lVmFsdWVBcnIuam9pbihcIj1cIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IG5hbWVWYWx1ZVBhaXJTdHI7XG4gICAgICB9XG4gICAgICByZXR1cm4geyBuYW1lLCB2YWx1ZSB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBwYXJzZTIoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID8gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdFBhcnNlT3B0aW9ucywgb3B0aW9ucykgOiBkZWZhdWx0UGFyc2VPcHRpb25zO1xuICAgICAgaWYgKCFpbnB1dCkge1xuICAgICAgICBpZiAoIW9wdGlvbnMubWFwKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlucHV0LmhlYWRlcnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBpbnB1dC5oZWFkZXJzLmdldFNldENvb2tpZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgaW5wdXQgPSBpbnB1dC5oZWFkZXJzLmdldFNldENvb2tpZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKGlucHV0LmhlYWRlcnNbXCJzZXQtY29va2llXCJdKSB7XG4gICAgICAgICAgaW5wdXQgPSBpbnB1dC5oZWFkZXJzW1wic2V0LWNvb2tpZVwiXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc2NoID0gaW5wdXQuaGVhZGVyc1tPYmplY3Qua2V5cyhpbnB1dC5oZWFkZXJzKS5maW5kKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIGtleS50b0xvd2VyQ2FzZSgpID09PSBcInNldC1jb29raWVcIjtcbiAgICAgICAgICB9KV07XG4gICAgICAgICAgaWYgKCFzY2ggJiYgaW5wdXQuaGVhZGVycy5jb29raWUgJiYgIW9wdGlvbnMuc2lsZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIFwiV2FybmluZzogc2V0LWNvb2tpZS1wYXJzZXIgYXBwZWFycyB0byBoYXZlIGJlZW4gY2FsbGVkIG9uIGEgcmVxdWVzdCBvYmplY3QuIEl0IGlzIGRlc2lnbmVkIHRvIHBhcnNlIFNldC1Db29raWUgaGVhZGVycyBmcm9tIHJlc3BvbnNlcywgbm90IENvb2tpZSBoZWFkZXJzIGZyb20gcmVxdWVzdHMuIFNldCB0aGUgb3B0aW9uIHtzaWxlbnQ6IHRydWV9IHRvIHN1cHByZXNzIHRoaXMgd2FybmluZy5cIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5wdXQgPSBzY2g7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICAgICAgaW5wdXQgPSBbaW5wdXRdO1xuICAgICAgfVxuICAgICAgaWYgKCFvcHRpb25zLm1hcCkge1xuICAgICAgICByZXR1cm4gaW5wdXQuZmlsdGVyKGlzTm9uRW1wdHlTdHJpbmcpLm1hcChmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICByZXR1cm4gcGFyc2VTdHJpbmcoc3RyLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29va2llcyA9IHt9O1xuICAgICAgICByZXR1cm4gaW5wdXQuZmlsdGVyKGlzTm9uRW1wdHlTdHJpbmcpLnJlZHVjZShmdW5jdGlvbihjb29raWVzMiwgc3RyKSB7XG4gICAgICAgICAgdmFyIGNvb2tpZSA9IHBhcnNlU3RyaW5nKHN0ciwgb3B0aW9ucyk7XG4gICAgICAgICAgY29va2llczJbY29va2llLm5hbWVdID0gY29va2llO1xuICAgICAgICAgIHJldHVybiBjb29raWVzMjtcbiAgICAgICAgfSwgY29va2llcyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNwbGl0Q29va2llc1N0cmluZzIoY29va2llc1N0cmluZykge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29va2llc1N0cmluZykpIHtcbiAgICAgICAgcmV0dXJuIGNvb2tpZXNTdHJpbmc7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNvb2tpZXNTdHJpbmcgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGNvb2tpZXNTdHJpbmdzID0gW107XG4gICAgICB2YXIgcG9zID0gMDtcbiAgICAgIHZhciBzdGFydDtcbiAgICAgIHZhciBjaDtcbiAgICAgIHZhciBsYXN0Q29tbWE7XG4gICAgICB2YXIgbmV4dFN0YXJ0O1xuICAgICAgdmFyIGNvb2tpZXNTZXBhcmF0b3JGb3VuZDtcbiAgICAgIGZ1bmN0aW9uIHNraXBXaGl0ZXNwYWNlKCkge1xuICAgICAgICB3aGlsZSAocG9zIDwgY29va2llc1N0cmluZy5sZW5ndGggJiYgL1xccy8udGVzdChjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIG5vdFNwZWNpYWxDaGFyKCkge1xuICAgICAgICBjaCA9IGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcyk7XG4gICAgICAgIHJldHVybiBjaCAhPT0gXCI9XCIgJiYgY2ggIT09IFwiO1wiICYmIGNoICE9PSBcIixcIjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCkge1xuICAgICAgICBzdGFydCA9IHBvcztcbiAgICAgICAgY29va2llc1NlcGFyYXRvckZvdW5kID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChza2lwV2hpdGVzcGFjZSgpKSB7XG4gICAgICAgICAgY2ggPSBjb29raWVzU3RyaW5nLmNoYXJBdChwb3MpO1xuICAgICAgICAgIGlmIChjaCA9PT0gXCIsXCIpIHtcbiAgICAgICAgICAgIGxhc3RDb21tYSA9IHBvcztcbiAgICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICAgICAgc2tpcFdoaXRlc3BhY2UoKTtcbiAgICAgICAgICAgIG5leHRTdGFydCA9IHBvcztcbiAgICAgICAgICAgIHdoaWxlIChwb3MgPCBjb29raWVzU3RyaW5nLmxlbmd0aCAmJiBub3RTcGVjaWFsQ2hhcigpKSB7XG4gICAgICAgICAgICAgIHBvcyArPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBvcyA8IGNvb2tpZXNTdHJpbmcubGVuZ3RoICYmIGNvb2tpZXNTdHJpbmcuY2hhckF0KHBvcykgPT09IFwiPVwiKSB7XG4gICAgICAgICAgICAgIGNvb2tpZXNTZXBhcmF0b3JGb3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgIHBvcyA9IG5leHRTdGFydDtcbiAgICAgICAgICAgICAgY29va2llc1N0cmluZ3MucHVzaChjb29raWVzU3RyaW5nLnN1YnN0cmluZyhzdGFydCwgbGFzdENvbW1hKSk7XG4gICAgICAgICAgICAgIHN0YXJ0ID0gcG9zO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcG9zID0gbGFzdENvbW1hICsgMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcG9zICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghY29va2llc1NlcGFyYXRvckZvdW5kIHx8IHBvcyA+PSBjb29raWVzU3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgIGNvb2tpZXNTdHJpbmdzLnB1c2goY29va2llc1N0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGNvb2tpZXNTdHJpbmcubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBjb29raWVzU3RyaW5ncztcbiAgICB9XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBwYXJzZTI7XG4gICAgbW9kdWxlLmV4cG9ydHMucGFyc2UgPSBwYXJzZTI7XG4gICAgbW9kdWxlLmV4cG9ydHMucGFyc2VTdHJpbmcgPSBwYXJzZVN0cmluZztcbiAgICBtb2R1bGUuZXhwb3J0cy5zcGxpdENvb2tpZXNTdHJpbmcgPSBzcGxpdENvb2tpZXNTdHJpbmcyO1xuICB9XG59KTtcblxuLy8gc3JjL2VuZHBvaW50LnRzXG5pbXBvcnQgeyBab2RFcnJvciB9IGZyb20gXCJ6b2RcIjtcblxuLy8gc3JjL2Vycm9yLnRzXG52YXIgQVBJRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc3RhdHVzLCBib2R5LCBoZWFkZXJzKSB7XG4gICAgc3VwZXIoYEFQSSBFcnJvcjogJHtzdGF0dXN9ICR7Ym9keT8ubWVzc2FnZSA/PyBcIlwifWAsIHtcbiAgICAgIGNhdXNlOiBib2R5XG4gICAgfSk7XG4gICAgX19wdWJsaWNGaWVsZCh0aGlzLCBcInN0YXR1c1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiaGVhZGVyc1wiKTtcbiAgICBfX3B1YmxpY0ZpZWxkKHRoaXMsIFwiYm9keVwiKTtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLmJvZHkgPSBib2R5ID8/IHt9O1xuICAgIHRoaXMuYm9keS5jb2RlID0gYm9keT8ubWVzc2FnZSA/IGJvZHkubWVzc2FnZS50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoLyAvZywgXCJfXCIpLnJlcGxhY2UoL1teQS1aMC05X10vZywgXCJcIikgOiBzdGF0dXM7XG4gICAgdGhpcy5zdGFjayA9IFwiXCI7XG4gICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycyA/PyBuZXcgSGVhZGVycygpO1xuICAgIGlmICghdGhpcy5oZWFkZXJzLmhhcyhcIkNvbnRlbnQtVHlwZVwiKSkge1xuICAgICAgdGhpcy5oZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgfVxuICAgIHRoaXMubmFtZSA9IFwiQmV0dGVyQ2FsbEFQSUVycm9yXCI7XG4gIH1cbn07XG5cbi8vIHNyYy9oZWxwZXIudHNcbnZhciBqc29uID0gKGJvZHksIG9wdGlvbikgPT4ge1xuICByZXR1cm4ge1xuICAgIHJlc3BvbnNlOiB7XG4gICAgICBib2R5OiBvcHRpb24/LmJvZHkgPz8gYm9keSxcbiAgICAgIHN0YXR1czogb3B0aW9uPy5zdGF0dXMgPz8gMjAwLFxuICAgICAgc3RhdHVzVGV4dDogb3B0aW9uPy5zdGF0dXNUZXh0ID8/IFwiT0tcIixcbiAgICAgIGhlYWRlcnM6IG9wdGlvbj8uaGVhZGVyc1xuICAgIH0sXG4gICAgYm9keSxcbiAgICBfZmxhZzogXCJqc29uXCJcbiAgfTtcbn07XG5cbi8vIHNyYy9jb29raWUudHNcbmltcG9ydCB7IHN1YnRsZSB9IGZyb20gXCJ1bmNyeXB0b1wiO1xudmFyIGFsZ29yaXRobSA9IHsgbmFtZTogXCJITUFDXCIsIGhhc2g6IFwiU0hBLTI1NlwiIH07XG52YXIgZ2V0Q3J5cHRvS2V5ID0gYXN5bmMgKHNlY3JldCkgPT4ge1xuICBjb25zdCBzZWNyZXRCdWYgPSB0eXBlb2Ygc2VjcmV0ID09PSBcInN0cmluZ1wiID8gbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHNlY3JldCkgOiBzZWNyZXQ7XG4gIHJldHVybiBhd2FpdCBzdWJ0bGUuaW1wb3J0S2V5KFwicmF3XCIsIHNlY3JldEJ1ZiwgYWxnb3JpdGhtLCBmYWxzZSwgW1wic2lnblwiLCBcInZlcmlmeVwiXSk7XG59O1xudmFyIG1ha2VTaWduYXR1cmUgPSBhc3luYyAodmFsdWUsIHNlY3JldCkgPT4ge1xuICBjb25zdCBrZXkgPSBhd2FpdCBnZXRDcnlwdG9LZXkoc2VjcmV0KTtcbiAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgc3VidGxlLnNpZ24oYWxnb3JpdGhtLm5hbWUsIGtleSwgbmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHZhbHVlKSk7XG4gIHJldHVybiBidG9hKFN0cmluZy5mcm9tQ2hhckNvZGUoLi4ubmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlKSkpO1xufTtcbnZhciB2ZXJpZnlTaWduYXR1cmUgPSBhc3luYyAoYmFzZTY0U2lnbmF0dXJlLCB2YWx1ZSwgc2VjcmV0KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlQmluU3RyID0gYXRvYihiYXNlNjRTaWduYXR1cmUpO1xuICAgIGNvbnN0IHNpZ25hdHVyZSA9IG5ldyBVaW50OEFycmF5KHNpZ25hdHVyZUJpblN0ci5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBzaWduYXR1cmVCaW5TdHIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHNpZ25hdHVyZVtpXSA9IHNpZ25hdHVyZUJpblN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgc3VidGxlLnZlcmlmeShhbGdvcml0aG0sIHNlY3JldCwgc2lnbmF0dXJlLCBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodmFsdWUpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbnZhciB2YWxpZENvb2tpZU5hbWVSZWdFeCA9IC9eW1xcdyEjJCUmJyouXmB8fistXSskLztcbnZhciB2YWxpZENvb2tpZVZhbHVlUmVnRXggPSAvXlsgISMtOjwtW1xcXS1+XSokLztcbnZhciBwYXJzZSA9IChjb29raWUsIG5hbWUpID0+IHtcbiAgY29uc3QgcGFpcnMgPSBjb29raWUudHJpbSgpLnNwbGl0KFwiO1wiKTtcbiAgcmV0dXJuIHBhaXJzLnJlZHVjZSgocGFyc2VkQ29va2llLCBwYWlyU3RyKSA9PiB7XG4gICAgcGFpclN0ciA9IHBhaXJTdHIudHJpbSgpO1xuICAgIGNvbnN0IHZhbHVlU3RhcnRQb3MgPSBwYWlyU3RyLmluZGV4T2YoXCI9XCIpO1xuICAgIGlmICh2YWx1ZVN0YXJ0UG9zID09PSAtMSkge1xuICAgICAgcmV0dXJuIHBhcnNlZENvb2tpZTtcbiAgICB9XG4gICAgY29uc3QgY29va2llTmFtZSA9IHBhaXJTdHIuc3Vic3RyaW5nKDAsIHZhbHVlU3RhcnRQb3MpLnRyaW0oKTtcbiAgICBpZiAobmFtZSAmJiBuYW1lICE9PSBjb29raWVOYW1lIHx8ICF2YWxpZENvb2tpZU5hbWVSZWdFeC50ZXN0KGNvb2tpZU5hbWUpKSB7XG4gICAgICByZXR1cm4gcGFyc2VkQ29va2llO1xuICAgIH1cbiAgICBsZXQgY29va2llVmFsdWUgPSBwYWlyU3RyLnN1YnN0cmluZyh2YWx1ZVN0YXJ0UG9zICsgMSkudHJpbSgpO1xuICAgIGlmIChjb29raWVWYWx1ZS5zdGFydHNXaXRoKCdcIicpICYmIGNvb2tpZVZhbHVlLmVuZHNXaXRoKCdcIicpKSB7XG4gICAgICBjb29raWVWYWx1ZSA9IGNvb2tpZVZhbHVlLnNsaWNlKDEsIC0xKTtcbiAgICB9XG4gICAgaWYgKHZhbGlkQ29va2llVmFsdWVSZWdFeC50ZXN0KGNvb2tpZVZhbHVlKSkge1xuICAgICAgcGFyc2VkQ29va2llW2Nvb2tpZU5hbWVdID0gZGVjb2RlVVJJQ29tcG9uZW50KGNvb2tpZVZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnNlZENvb2tpZTtcbiAgfSwge30pO1xufTtcbnZhciBwYXJzZVNpZ25lZCA9IGFzeW5jIChjb29raWUsIHNlY3JldCwgbmFtZSkgPT4ge1xuICBjb25zdCBwYXJzZWRDb29raWUgPSB7fTtcbiAgY29uc3Qgc2VjcmV0S2V5ID0gYXdhaXQgZ2V0Q3J5cHRvS2V5KHNlY3JldCk7XG4gIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHBhcnNlKGNvb2tpZSwgbmFtZSkpKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlU3RhcnRQb3MgPSB2YWx1ZS5sYXN0SW5kZXhPZihcIi5cIik7XG4gICAgaWYgKHNpZ25hdHVyZVN0YXJ0UG9zIDwgMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IHNpZ25lZFZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHNpZ25hdHVyZVN0YXJ0UG9zKTtcbiAgICBjb25zdCBzaWduYXR1cmUgPSB2YWx1ZS5zdWJzdHJpbmcoc2lnbmF0dXJlU3RhcnRQb3MgKyAxKTtcbiAgICBpZiAoc2lnbmF0dXJlLmxlbmd0aCAhPT0gNDQgfHwgIXNpZ25hdHVyZS5lbmRzV2l0aChcIj1cIikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBpc1ZlcmlmaWVkID0gYXdhaXQgdmVyaWZ5U2lnbmF0dXJlKHNpZ25hdHVyZSwgc2lnbmVkVmFsdWUsIHNlY3JldEtleSk7XG4gICAgcGFyc2VkQ29va2llW2tleV0gPSBpc1ZlcmlmaWVkID8gc2lnbmVkVmFsdWUgOiBmYWxzZTtcbiAgfVxuICByZXR1cm4gcGFyc2VkQ29va2llO1xufTtcbnZhciBfc2VyaWFsaXplID0gKG5hbWUsIHZhbHVlLCBvcHQgPSB7fSkgPT4ge1xuICBsZXQgY29va2llID0gYCR7bmFtZX09JHt2YWx1ZX1gO1xuICBpZiAobmFtZS5zdGFydHNXaXRoKFwiX19TZWN1cmUtXCIpICYmICFvcHQuc2VjdXJlKSB7XG4gICAgb3B0LnNlY3VyZSA9IHRydWU7XG4gIH1cbiAgaWYgKG5hbWUuc3RhcnRzV2l0aChcIl9fSG9zdC1cIikpIHtcbiAgICBpZiAoIW9wdC5zZWN1cmUpIHtcbiAgICAgIG9wdC5zZWN1cmUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0LnBhdGggIT09IFwiL1wiKSB7XG4gICAgICBvcHQucGF0aCA9IFwiL1wiO1xuICAgIH1cbiAgICBpZiAob3B0LmRvbWFpbikge1xuICAgICAgb3B0LmRvbWFpbiA9IHZvaWQgMDtcbiAgICB9XG4gIH1cbiAgaWYgKG9wdCAmJiB0eXBlb2Ygb3B0Lm1heEFnZSA9PT0gXCJudW1iZXJcIiAmJiBvcHQubWF4QWdlID49IDApIHtcbiAgICBpZiAob3B0Lm1heEFnZSA+IDM0NTZlNCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBcIkNvb2tpZXMgTWF4LUFnZSBTSE9VTEQgTk9UIGJlIGdyZWF0ZXIgdGhhbiA0MDAgZGF5cyAoMzQ1NjAwMDAgc2Vjb25kcykgaW4gZHVyYXRpb24uXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvb2tpZSArPSBgOyBNYXgtQWdlPSR7TWF0aC5mbG9vcihvcHQubWF4QWdlKX1gO1xuICB9XG4gIGlmIChvcHQuZG9tYWluICYmIG9wdC5wcmVmaXggIT09IFwiaG9zdFwiKSB7XG4gICAgY29va2llICs9IGA7IERvbWFpbj0ke29wdC5kb21haW59YDtcbiAgfVxuICBpZiAob3B0LnBhdGgpIHtcbiAgICBjb29raWUgKz0gYDsgUGF0aD0ke29wdC5wYXRofWA7XG4gIH1cbiAgaWYgKG9wdC5leHBpcmVzKSB7XG4gICAgaWYgKG9wdC5leHBpcmVzLmdldFRpbWUoKSAtIERhdGUubm93KCkgPiAzNDU2ZTcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJDb29raWVzIEV4cGlyZXMgU0hPVUxEIE5PVCBiZSBncmVhdGVyIHRoYW4gNDAwIGRheXMgKDM0NTYwMDAwIHNlY29uZHMpIGluIHRoZSBmdXR1cmUuXCJcbiAgICAgICk7XG4gICAgfVxuICAgIGNvb2tpZSArPSBgOyBFeHBpcmVzPSR7b3B0LmV4cGlyZXMudG9VVENTdHJpbmcoKX1gO1xuICB9XG4gIGlmIChvcHQuaHR0cE9ubHkpIHtcbiAgICBjb29raWUgKz0gXCI7IEh0dHBPbmx5XCI7XG4gIH1cbiAgaWYgKG9wdC5zZWN1cmUpIHtcbiAgICBjb29raWUgKz0gXCI7IFNlY3VyZVwiO1xuICB9XG4gIGlmIChvcHQuc2FtZVNpdGUpIHtcbiAgICBjb29raWUgKz0gYDsgU2FtZVNpdGU9JHtvcHQuc2FtZVNpdGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBvcHQuc2FtZVNpdGUuc2xpY2UoMSl9YDtcbiAgfVxuICBpZiAob3B0LnBhcnRpdGlvbmVkKSB7XG4gICAgaWYgKCFvcHQuc2VjdXJlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYXJ0aXRpb25lZCBDb29raWUgbXVzdCBoYXZlIFNlY3VyZSBhdHRyaWJ1dGVzXCIpO1xuICAgIH1cbiAgICBjb29raWUgKz0gXCI7IFBhcnRpdGlvbmVkXCI7XG4gIH1cbiAgcmV0dXJuIGNvb2tpZTtcbn07XG52YXIgc2VyaWFsaXplID0gKG5hbWUsIHZhbHVlLCBvcHQpID0+IHtcbiAgdmFsdWUgPSBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuICByZXR1cm4gX3NlcmlhbGl6ZShuYW1lLCB2YWx1ZSwgb3B0KTtcbn07XG52YXIgc2VyaWFsaXplU2lnbmVkID0gYXN5bmMgKG5hbWUsIHZhbHVlLCBzZWNyZXQsIG9wdCA9IHt9KSA9PiB7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IG1ha2VTaWduYXR1cmUodmFsdWUsIHNlY3JldCk7XG4gIHZhbHVlID0gYCR7dmFsdWV9LiR7c2lnbmF0dXJlfWA7XG4gIHZhbHVlID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgcmV0dXJuIF9zZXJpYWxpemUobmFtZSwgdmFsdWUsIG9wdCk7XG59O1xudmFyIHNpZ25Db29raWVWYWx1ZSA9IGFzeW5jICh2YWx1ZSwgc2VjcmV0KSA9PiB7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IG1ha2VTaWduYXR1cmUodmFsdWUsIHNlY3JldCk7XG4gIHZhbHVlID0gYCR7dmFsdWV9LiR7c2lnbmF0dXJlfWA7XG4gIHZhbHVlID0gZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufTtcblxuLy8gc3JjL2Nvb2tpZS11dGlscy50c1xudmFyIGdldENvb2tpZSA9IChjb29raWUsIGtleSwgcHJlZml4KSA9PiB7XG4gIGlmICghY29va2llKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBsZXQgZmluYWxLZXkgPSBrZXk7XG4gIGlmIChwcmVmaXgpIHtcbiAgICBpZiAocHJlZml4ID09PSBcInNlY3VyZVwiKSB7XG4gICAgICBmaW5hbEtleSA9IFwiX19TZWN1cmUtXCIgKyBrZXk7XG4gICAgfSBlbHNlIGlmIChwcmVmaXggPT09IFwiaG9zdFwiKSB7XG4gICAgICBmaW5hbEtleSA9IFwiX19Ib3N0LVwiICsga2V5O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgfVxuICBjb25zdCBvYmogPSBwYXJzZShjb29raWUsIGZpbmFsS2V5KTtcbiAgcmV0dXJuIG9ialtmaW5hbEtleV07XG59O1xudmFyIHNldENvb2tpZSA9IChoZWFkZXIsIG5hbWUsIHZhbHVlLCBvcHQpID0+IHtcbiAgY29uc3QgZXhpc3RpbmdDb29raWVzID0gaGVhZGVyLmdldChcIlNldC1Db29raWVcIik7XG4gIGlmIChleGlzdGluZ0Nvb2tpZXMpIHtcbiAgICBjb25zdCBjb29raWVzID0gZXhpc3RpbmdDb29raWVzLnNwbGl0KFwiLCBcIik7XG4gICAgY29uc3QgdXBkYXRlZENvb2tpZXMgPSBjb29raWVzLmZpbHRlcigoY29va2llMikgPT4gIWNvb2tpZTIuc3RhcnRzV2l0aChgJHtuYW1lfT1gKSk7XG4gICAgaGVhZGVyLmRlbGV0ZShcIlNldC1Db29raWVcIik7XG4gICAgdXBkYXRlZENvb2tpZXMuZm9yRWFjaCgoY29va2llMikgPT4gaGVhZGVyLmFwcGVuZChcIlNldC1Db29raWVcIiwgY29va2llMikpO1xuICB9XG4gIGxldCBjb29raWU7XG4gIGlmIChvcHQ/LnByZWZpeCA9PT0gXCJzZWN1cmVcIikge1xuICAgIGNvb2tpZSA9IHNlcmlhbGl6ZShcIl9fU2VjdXJlLVwiICsgbmFtZSwgdmFsdWUsIHsgcGF0aDogXCIvXCIsIC4uLm9wdCwgc2VjdXJlOiB0cnVlIH0pO1xuICB9IGVsc2UgaWYgKG9wdD8ucHJlZml4ID09PSBcImhvc3RcIikge1xuICAgIGNvb2tpZSA9IHNlcmlhbGl6ZShcIl9fSG9zdC1cIiArIG5hbWUsIHZhbHVlLCB7XG4gICAgICAuLi5vcHQsXG4gICAgICBwYXRoOiBcIi9cIixcbiAgICAgIHNlY3VyZTogdHJ1ZSxcbiAgICAgIGRvbWFpbjogdm9pZCAwXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29va2llID0gc2VyaWFsaXplKG5hbWUsIHZhbHVlLCB7IHBhdGg6IFwiL1wiLCAuLi5vcHQgfSk7XG4gIH1cbiAgaGVhZGVyLmFwcGVuZChcIlNldC1Db29raWVcIiwgY29va2llKTtcbn07XG52YXIgc2V0U2lnbmVkQ29va2llID0gYXN5bmMgKGhlYWRlciwgbmFtZSwgdmFsdWUsIHNlY3JldCwgb3B0KSA9PiB7XG4gIGxldCBjb29raWU7XG4gIGlmIChvcHQ/LnByZWZpeCA9PT0gXCJzZWN1cmVcIikge1xuICAgIGNvb2tpZSA9IGF3YWl0IHNlcmlhbGl6ZVNpZ25lZChcIl9fU2VjdXJlLVwiICsgbmFtZSwgdmFsdWUsIHNlY3JldCwge1xuICAgICAgcGF0aDogXCIvXCIsXG4gICAgICAuLi5vcHQsXG4gICAgICBzZWN1cmU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChvcHQ/LnByZWZpeCA9PT0gXCJob3N0XCIpIHtcbiAgICBjb29raWUgPSBhd2FpdCBzZXJpYWxpemVTaWduZWQoXCJfX0hvc3QtXCIgKyBuYW1lLCB2YWx1ZSwgc2VjcmV0LCB7XG4gICAgICAuLi5vcHQsXG4gICAgICBwYXRoOiBcIi9cIixcbiAgICAgIHNlY3VyZTogdHJ1ZSxcbiAgICAgIGRvbWFpbjogdm9pZCAwXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgY29va2llID0gYXdhaXQgc2VyaWFsaXplU2lnbmVkKG5hbWUsIHZhbHVlLCBzZWNyZXQsIHsgcGF0aDogXCIvXCIsIC4uLm9wdCB9KTtcbiAgfVxuICBoZWFkZXIuYXBwZW5kKFwiU2V0LUNvb2tpZVwiLCBjb29raWUpO1xufTtcbnZhciBnZXRTaWduZWRDb29raWUgPSBhc3luYyAoaGVhZGVyLCBzZWNyZXQsIGtleSwgcHJlZml4KSA9PiB7XG4gIGNvbnN0IGNvb2tpZSA9IGhlYWRlci5nZXQoXCJjb29raWVcIik7XG4gIGlmICghY29va2llKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBsZXQgZmluYWxLZXkgPSBrZXk7XG4gIGlmIChwcmVmaXgpIHtcbiAgICBpZiAocHJlZml4ID09PSBcInNlY3VyZVwiKSB7XG4gICAgICBmaW5hbEtleSA9IFwiX19TZWN1cmUtXCIgKyBrZXk7XG4gICAgfSBlbHNlIGlmIChwcmVmaXggPT09IFwiaG9zdFwiKSB7XG4gICAgICBmaW5hbEtleSA9IFwiX19Ib3N0LVwiICsga2V5O1xuICAgIH1cbiAgfVxuICBjb25zdCBvYmogPSBhd2FpdCBwYXJzZVNpZ25lZChjb29raWUsIHNlY3JldCwgZmluYWxLZXkpO1xuICByZXR1cm4gb2JqW2ZpbmFsS2V5XTtcbn07XG5cbi8vIHNyYy9lbmRwb2ludC50c1xuZnVuY3Rpb24gY3JlYXRlRW5kcG9pbnRDcmVhdG9yKG9wdHMpIHtcbiAgcmV0dXJuIChwYXRoLCBvcHRpb25zLCBoYW5kbGVyKSA9PiB7XG4gICAgcmV0dXJuIGNyZWF0ZUVuZHBvaW50KFxuICAgICAgcGF0aCxcbiAgICAgIHtcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgdXNlOiBbLi4ub3B0aW9ucz8udXNlIHx8IFtdLCAuLi5vcHRzPy51c2UgfHwgW11dXG4gICAgICB9LFxuICAgICAgaGFuZGxlclxuICAgICk7XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVFbmRwb2ludChwYXRoLCBvcHRpb25zLCBoYW5kbGVyKSB7XG4gIGxldCByZXNwb25zZUhlYWRlciA9IG5ldyBIZWFkZXJzKCk7XG4gIGNvbnN0IGhhbmRsZSA9IGFzeW5jICguLi5jdHgpID0+IHtcbiAgICBsZXQgaW50ZXJuYWxDdHggPSB7XG4gICAgICBzZXRIZWFkZXIoa2V5LCB2YWx1ZSkge1xuICAgICAgICByZXNwb25zZUhlYWRlci5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB9LFxuICAgICAgc2V0Q29va2llKGtleSwgdmFsdWUsIG9wdGlvbnMyKSB7XG4gICAgICAgIHNldENvb2tpZShyZXNwb25zZUhlYWRlciwga2V5LCB2YWx1ZSwgb3B0aW9uczIpO1xuICAgICAgfSxcbiAgICAgIGdldENvb2tpZShrZXksIHByZWZpeCkge1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBjdHhbMF0/LmhlYWRlcnM7XG4gICAgICAgIGNvbnN0IGNvb2tpZUggPSBoZWFkZXI/LmdldChcImNvb2tpZVwiKTtcbiAgICAgICAgY29uc3QgY29va2llID0gZ2V0Q29va2llKGNvb2tpZUggfHwgXCJcIiwga2V5LCBwcmVmaXgpO1xuICAgICAgICByZXR1cm4gY29va2llO1xuICAgICAgfSxcbiAgICAgIGdldFNpZ25lZENvb2tpZShrZXksIHNlY3JldCwgcHJlZml4KSB7XG4gICAgICAgIGNvbnN0IGhlYWRlciA9IGN0eFswXT8uaGVhZGVycztcbiAgICAgICAgaWYgKCFoZWFkZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSGVhZGVycyBhcmUgcmVxdWlyZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29va2llID0gZ2V0U2lnbmVkQ29va2llKGhlYWRlciwgc2VjcmV0LCBrZXksIHByZWZpeCk7XG4gICAgICAgIHJldHVybiBjb29raWU7XG4gICAgICB9LFxuICAgICAgYXN5bmMgc2V0U2lnbmVkQ29va2llKGtleSwgdmFsdWUsIHNlY3JldCwgb3B0aW9uczIpIHtcbiAgICAgICAgYXdhaXQgc2V0U2lnbmVkQ29va2llKHJlc3BvbnNlSGVhZGVyLCBrZXksIHZhbHVlLCBzZWNyZXQsIG9wdGlvbnMyKTtcbiAgICAgIH0sXG4gICAgICByZWRpcmVjdCh1cmwpIHtcbiAgICAgICAgcmVzcG9uc2VIZWFkZXIuc2V0KFwiTG9jYXRpb25cIiwgdXJsKTtcbiAgICAgICAgcmV0dXJuIG5ldyBBUElFcnJvcihcIkZPVU5EXCIpO1xuICAgICAgfSxcbiAgICAgIGpzb24sXG4gICAgICBjb250ZXh0OiBjdHhbMF0/LmNvbnRleHQgfHwge30sXG4gICAgICBfZmxhZzogY3R4WzBdPy5hc1Jlc3BvbnNlID8gXCJyb3V0ZXJcIiA6IGN0eFswXT8uX2ZsYWcsXG4gICAgICByZXNwb25zZUhlYWRlcixcbiAgICAgIHBhdGgsXG4gICAgICAuLi5jdHhbMF0gfHwge31cbiAgICB9O1xuICAgIGlmIChvcHRpb25zLnVzZT8ubGVuZ3RoKSB7XG4gICAgICBsZXQgbWlkZGxld2FyZUNvbnRleHRzID0ge307XG4gICAgICBsZXQgbWlkZGxld2FyZUJvZHkgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgbWlkZGxld2FyZSBvZiBvcHRpb25zLnVzZSkge1xuICAgICAgICBpZiAodHlwZW9mIG1pZGRsZXdhcmUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIk1pZGRsZXdhcmUgaXMgbm90IGEgZnVuY3Rpb25cIiwge1xuICAgICAgICAgICAgbWlkZGxld2FyZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IG1pZGRsZXdhcmUoaW50ZXJuYWxDdHgpO1xuICAgICAgICBpZiAocmVzKSB7XG4gICAgICAgICAgY29uc3QgYm9keSA9IHJlcy5vcHRpb25zPy5ib2R5ID8gcmVzLm9wdGlvbnMuYm9keS5wYXJzZShpbnRlcm5hbEN0eC5ib2R5KSA6IHZvaWQgMDtcbiAgICAgICAgICBtaWRkbGV3YXJlQ29udGV4dHMgPSB7XG4gICAgICAgICAgICAuLi5taWRkbGV3YXJlQ29udGV4dHMsXG4gICAgICAgICAgICAuLi5yZXNcbiAgICAgICAgICB9O1xuICAgICAgICAgIG1pZGRsZXdhcmVCb2R5ID0ge1xuICAgICAgICAgICAgLi4ubWlkZGxld2FyZUJvZHksXG4gICAgICAgICAgICAuLi5ib2R5XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaW50ZXJuYWxDdHggPSB7XG4gICAgICAgIC4uLmludGVybmFsQ3R4LFxuICAgICAgICBib2R5OiB7XG4gICAgICAgICAgLi4ubWlkZGxld2FyZUJvZHksXG4gICAgICAgICAgLi4uaW50ZXJuYWxDdHguYm9keVxuICAgICAgICB9LFxuICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgLi4uaW50ZXJuYWxDdHguY29udGV4dCB8fCB7fSxcbiAgICAgICAgICAuLi5taWRkbGV3YXJlQ29udGV4dHNcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGJvZHkgPSBvcHRpb25zLmJvZHkgPyBvcHRpb25zLmJvZHkucGFyc2UoaW50ZXJuYWxDdHguYm9keSkgOiBpbnRlcm5hbEN0eC5ib2R5O1xuICAgICAgaW50ZXJuYWxDdHggPSB7XG4gICAgICAgIC4uLmludGVybmFsQ3R4LFxuICAgICAgICBib2R5OiBib2R5ID8ge1xuICAgICAgICAgIC4uLmJvZHksXG4gICAgICAgICAgLi4uaW50ZXJuYWxDdHguYm9keVxuICAgICAgICB9IDogaW50ZXJuYWxDdHguYm9keVxuICAgICAgfTtcbiAgICAgIGludGVybmFsQ3R4LnF1ZXJ5ID0gb3B0aW9ucy5xdWVyeSA/IG9wdGlvbnMucXVlcnkucGFyc2UoaW50ZXJuYWxDdHgucXVlcnkpIDogaW50ZXJuYWxDdHgucXVlcnk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBab2RFcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgQVBJRXJyb3IoXCJCQURfUkVRVUVTVFwiLCB7XG4gICAgICAgICAgbWVzc2FnZTogZS5tZXNzYWdlLFxuICAgICAgICAgIGRldGFpbHM6IGUuZXJyb3JzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucmVxdWlyZUhlYWRlcnMgJiYgIWludGVybmFsQ3R4LmhlYWRlcnMpIHtcbiAgICAgIHRocm93IG5ldyBBUElFcnJvcihcIkJBRF9SRVFVRVNUXCIsIHtcbiAgICAgICAgbWVzc2FnZTogXCJIZWFkZXJzIGFyZSByZXF1aXJlZFwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucmVxdWlyZVJlcXVlc3QgJiYgIWludGVybmFsQ3R4LnJlcXVlc3QpIHtcbiAgICAgIHRocm93IG5ldyBBUElFcnJvcihcIkJBRF9SRVFVRVNUXCIsIHtcbiAgICAgICAgbWVzc2FnZTogXCJSZXF1ZXN0IGlzIHJlcXVpcmVkXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaW50ZXJuYWxDdHgucmVxdWVzdCAmJiAhaW50ZXJuYWxDdHguaGVhZGVycykge1xuICAgICAgaW50ZXJuYWxDdHguaGVhZGVycyA9IGludGVybmFsQ3R4LnJlcXVlc3QuaGVhZGVycztcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGxldCByZXMgPSBhd2FpdCBoYW5kbGVyKGludGVybmFsQ3R4KTtcbiAgICAgIGxldCBhY3R1YWxSZXNwb25zZSA9IHJlcztcbiAgICAgIGlmIChyZXMgJiYgdHlwZW9mIHJlcyA9PT0gXCJvYmplY3RcIiAmJiBcIl9mbGFnXCIgaW4gcmVzKSB7XG4gICAgICAgIGlmIChyZXMuX2ZsYWcgPT09IFwianNvblwiICYmIGludGVybmFsQ3R4Ll9mbGFnID09PSBcInJvdXRlclwiKSB7XG4gICAgICAgICAgY29uc3QgaCA9IHJlcy5yZXNwb25zZS5oZWFkZXJzO1xuICAgICAgICAgIE9iamVjdC5rZXlzKGggfHwge30pLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgcmVzcG9uc2VIZWFkZXIuc2V0KGtleSwgaFtrZXldKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXNwb25zZUhlYWRlci5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgICAgICAgIGFjdHVhbFJlc3BvbnNlID0gbmV3IFJlc3BvbnNlKEpTT04uc3RyaW5naWZ5KHJlcy5yZXNwb25zZS5ib2R5KSwge1xuICAgICAgICAgICAgc3RhdHVzOiByZXMucmVzcG9uc2Uuc3RhdHVzID8/IDIwMCxcbiAgICAgICAgICAgIHN0YXR1c1RleHQ6IHJlcy5yZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY3R1YWxSZXNwb25zZSA9IHJlcy5ib2R5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXNwb25zZUhlYWRlciA9IG5ldyBIZWFkZXJzKCk7XG4gICAgICByZXR1cm4gYWN0dWFsUmVzcG9uc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBBUElFcnJvcikge1xuICAgICAgICByZXNwb25zZUhlYWRlci5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuICAgICAgICBlLmhlYWRlcnMgPSByZXNwb25zZUhlYWRlcjtcbiAgICAgICAgcmVzcG9uc2VIZWFkZXIgPSBuZXcgSGVhZGVycygpO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH07XG4gIGhhbmRsZS5wYXRoID0gcGF0aDtcbiAgaGFuZGxlLm9wdGlvbnMgPSBvcHRpb25zO1xuICBoYW5kbGUubWV0aG9kID0gb3B0aW9ucy5tZXRob2Q7XG4gIGhhbmRsZS5oZWFkZXJzID0gcmVzcG9uc2VIZWFkZXI7XG4gIHJldHVybiBoYW5kbGU7XG59XG5cbi8vIHNyYy9yb3V0ZXIudHNcbmltcG9ydCB7IGNyZWF0ZVJvdXRlciBhcyBjcmVhdGVSb3UzUm91dGVyLCBhZGRSb3V0ZSwgZmluZFJvdXRlLCBmaW5kQWxsUm91dGVzIH0gZnJvbSBcInJvdTNcIjtcblxuLy8gc3JjL3V0aWxzLnRzXG5hc3luYyBmdW5jdGlvbiBnZXRCb2R5KHJlcXVlc3QpIHtcbiAgY29uc3QgY29udGVudFR5cGUgPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpIHx8IFwiXCI7XG4gIGlmICghcmVxdWVzdC5ib2R5KSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBpZiAoY29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgcmV0dXJuIGF3YWl0IHJlcXVlc3QuanNvbigpO1xuICB9XG4gIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSkge1xuICAgIGNvbnN0IGZvcm1EYXRhID0gYXdhaXQgcmVxdWVzdC5mb3JtRGF0YSgpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgIGZvcm1EYXRhLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcIm11bHRpcGFydC9mb3JtLWRhdGFcIikpIHtcbiAgICBjb25zdCBmb3JtRGF0YSA9IGF3YWl0IHJlcXVlc3QuZm9ybURhdGEoKTtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3JtRGF0YS5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgaWYgKGNvbnRlbnRUeXBlLmluY2x1ZGVzKFwidGV4dC9wbGFpblwiKSkge1xuICAgIHJldHVybiBhd2FpdCByZXF1ZXN0LnRleHQoKTtcbiAgfVxuICBpZiAoY29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIikpIHtcbiAgICByZXR1cm4gYXdhaXQgcmVxdWVzdC5hcnJheUJ1ZmZlcigpO1xuICB9XG4gIGlmIChjb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL3BkZlwiKSB8fCBjb250ZW50VHlwZS5pbmNsdWRlcyhcImltYWdlL1wiKSB8fCBjb250ZW50VHlwZS5pbmNsdWRlcyhcInZpZGVvL1wiKSkge1xuICAgIGNvbnN0IGJsb2IgPSBhd2FpdCByZXF1ZXN0LmJsb2IoKTtcbiAgICByZXR1cm4gYmxvYjtcbiAgfVxuICBpZiAoY29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9zdHJlYW1cIikgfHwgcmVxdWVzdC5ib2R5IGluc3RhbmNlb2YgUmVhZGFibGVTdHJlYW0pIHtcbiAgICByZXR1cm4gcmVxdWVzdC5ib2R5O1xuICB9XG4gIHJldHVybiBhd2FpdCByZXF1ZXN0LnRleHQoKTtcbn1cbmZ1bmN0aW9uIHNob3VsZFNlcmlhbGl6ZShib2R5KSB7XG4gIHJldHVybiB0eXBlb2YgYm9keSA9PT0gXCJvYmplY3RcIiAmJiBib2R5ICE9PSBudWxsICYmICEoYm9keSBpbnN0YW5jZW9mIEJsb2IpICYmICEoYm9keSBpbnN0YW5jZW9mIEZvcm1EYXRhKTtcbn1cbnZhciBzdGF0dXNDb2RlID0ge1xuICBPSzogMjAwLFxuICBDUkVBVEVEOiAyMDEsXG4gIEFDQ0VQVEVEOiAyMDIsXG4gIE5PX0NPTlRFTlQ6IDIwNCxcbiAgTVVMVElQTEVfQ0hPSUNFUzogMzAwLFxuICBNT1ZFRF9QRVJNQU5FTlRMWTogMzAxLFxuICBGT1VORDogMzAyLFxuICBTRUVfT1RIRVI6IDMwMyxcbiAgTk9UX01PRElGSUVEOiAzMDQsXG4gIFRFTVBPUkFSWV9SRURJUkVDVDogMzA3LFxuICBCQURfUkVRVUVTVDogNDAwLFxuICBVTkFVVEhPUklaRUQ6IDQwMSxcbiAgUEFZTUVOVF9SRVFVSVJFRDogNDAyLFxuICBGT1JCSURERU46IDQwMyxcbiAgTk9UX0ZPVU5EOiA0MDQsXG4gIE1FVEhPRF9OT1RfQUxMT1dFRDogNDA1LFxuICBOT1RfQUNDRVBUQUJMRTogNDA2LFxuICBQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRDogNDA3LFxuICBSRVFVRVNUX1RJTUVPVVQ6IDQwOCxcbiAgQ09ORkxJQ1Q6IDQwOSxcbiAgR09ORTogNDEwLFxuICBMRU5HVEhfUkVRVUlSRUQ6IDQxMSxcbiAgUFJFQ09ORElUSU9OX0ZBSUxFRDogNDEyLFxuICBQQVlMT0FEX1RPT19MQVJHRTogNDEzLFxuICBVUklfVE9PX0xPTkc6IDQxNCxcbiAgVU5TVVBQT1JURURfTUVESUFfVFlQRTogNDE1LFxuICBSQU5HRV9OT1RfU0FUSVNGSUFCTEU6IDQxNixcbiAgRVhQRUNUQVRJT05fRkFJTEVEOiA0MTcsXG4gIFwiSSdNX0FfVEVBUE9UXCI6IDQxOCxcbiAgTUlTRElSRUNURURfUkVRVUVTVDogNDIxLFxuICBVTlBST0NFU1NBQkxFX0VOVElUWTogNDIyLFxuICBMT0NLRUQ6IDQyMyxcbiAgRkFJTEVEX0RFUEVOREVOQ1k6IDQyNCxcbiAgVE9PX0VBUkxZOiA0MjUsXG4gIFVQR1JBREVfUkVRVUlSRUQ6IDQyNixcbiAgUFJFQ09ORElUSU9OX1JFUVVJUkVEOiA0MjgsXG4gIFRPT19NQU5ZX1JFUVVFU1RTOiA0MjksXG4gIFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0U6IDQzMSxcbiAgVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlM6IDQ1MSxcbiAgSU5URVJOQUxfU0VSVkVSX0VSUk9SOiA1MDAsXG4gIE5PVF9JTVBMRU1FTlRFRDogNTAxLFxuICBCQURfR0FURVdBWTogNTAyLFxuICBTRVJWSUNFX1VOQVZBSUxBQkxFOiA1MDMsXG4gIEdBVEVXQVlfVElNRU9VVDogNTA0LFxuICBIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRDogNTA1LFxuICBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUzogNTA2LFxuICBJTlNVRkZJQ0lFTlRfU1RPUkFHRTogNTA3LFxuICBMT09QX0RFVEVDVEVEOiA1MDgsXG4gIE5PVF9FWFRFTkRFRDogNTEwLFxuICBORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEOiA1MTFcbn07XG5cbi8vIHNyYy9yb3V0ZXIudHNcbnZhciBjcmVhdGVSb3V0ZXIgPSAoZW5kcG9pbnRzLCBjb25maWcpID0+IHtcbiAgY29uc3QgX2VuZHBvaW50cyA9IE9iamVjdC52YWx1ZXMoZW5kcG9pbnRzKTtcbiAgY29uc3Qgcm91dGVyID0gY3JlYXRlUm91M1JvdXRlcigpO1xuICBmb3IgKGNvbnN0IGVuZHBvaW50IG9mIF9lbmRwb2ludHMpIHtcbiAgICBpZiAoZW5kcG9pbnQub3B0aW9ucy5tZXRhZGF0YT8uU0VSVkVSX09OTFkpIGNvbnRpbnVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGVuZHBvaW50Lm9wdGlvbnM/Lm1ldGhvZCkpIHtcbiAgICAgIGZvciAoY29uc3QgbWV0aG9kIG9mIGVuZHBvaW50Lm9wdGlvbnMubWV0aG9kKSB7XG4gICAgICAgIGFkZFJvdXRlKHJvdXRlciwgbWV0aG9kLCBlbmRwb2ludC5wYXRoLCBlbmRwb2ludCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGFkZFJvdXRlKHJvdXRlciwgZW5kcG9pbnQub3B0aW9ucy5tZXRob2QsIGVuZHBvaW50LnBhdGgsIGVuZHBvaW50KTtcbiAgICB9XG4gIH1cbiAgY29uc3QgbWlkZGxld2FyZVJvdXRlciA9IGNyZWF0ZVJvdTNSb3V0ZXIoKTtcbiAgZm9yIChjb25zdCByb3V0ZSBvZiBjb25maWc/LnJvdXRlck1pZGRsZXdhcmUgfHwgW10pIHtcbiAgICBhZGRSb3V0ZShtaWRkbGV3YXJlUm91dGVyLCBcIipcIiwgcm91dGUucGF0aCwgcm91dGUubWlkZGxld2FyZSk7XG4gIH1cbiAgY29uc3QgaGFuZGxlciA9IGFzeW5jIChyZXF1ZXN0KSA9PiB7XG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChyZXF1ZXN0LnVybCk7XG4gICAgbGV0IHBhdGggPSB1cmwucGF0aG5hbWU7XG4gICAgaWYgKGNvbmZpZz8uYmFzZVBhdGgpIHtcbiAgICAgIHBhdGggPSBwYXRoLnNwbGl0KGNvbmZpZy5iYXNlUGF0aClbMV07XG4gICAgfVxuICAgIGlmICghcGF0aD8ubGVuZ3RoKSB7XG4gICAgICBjb25maWc/Lm9uRXJyb3I/LihuZXcgQVBJRXJyb3IoXCJOT1RfRk9VTkRcIikpO1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBgW2JldHRlci1jYWxsXTogTWFrZSBzdXJlIHRoZSBVUkwgaGFzIHRoZSBiYXNlUGF0aCAoJHtjb25maWc/LmJhc2VQYXRofSkuYFxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICBzdGF0dXM6IDQwNCxcbiAgICAgICAgc3RhdHVzVGV4dDogXCJOb3QgRm91bmRcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IG1ldGhvZCA9IHJlcXVlc3QubWV0aG9kO1xuICAgIGNvbnN0IHJvdXRlID0gZmluZFJvdXRlKHJvdXRlciwgbWV0aG9kLCBwYXRoKTtcbiAgICBjb25zdCBoYW5kbGVyMiA9IHJvdXRlPy5kYXRhO1xuICAgIGNvbnN0IGJvZHkgPSBhd2FpdCBnZXRCb2R5KHJlcXVlc3QpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSByZXF1ZXN0LmhlYWRlcnM7XG4gICAgY29uc3QgcXVlcnkgPSBPYmplY3QuZnJvbUVudHJpZXModXJsLnNlYXJjaFBhcmFtcyk7XG4gICAgY29uc3Qgcm91dGVyTWlkZGxld2FyZSA9IGZpbmRBbGxSb3V0ZXMobWlkZGxld2FyZVJvdXRlciwgXCIqXCIsIHBhdGgpO1xuICAgIGlmICghaGFuZGxlcjIpIHtcbiAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UobnVsbCwge1xuICAgICAgICBzdGF0dXM6IDQwNCxcbiAgICAgICAgc3RhdHVzVGV4dDogXCJOb3QgRm91bmRcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBsZXQgbWlkZGxld2FyZUNvbnRleHQgPSB7fTtcbiAgICAgIGlmIChyb3V0ZXJNaWRkbGV3YXJlPy5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChjb25zdCByb3V0ZTIgb2Ygcm91dGVyTWlkZGxld2FyZSkge1xuICAgICAgICAgIGNvbnN0IG1pZGRsZXdhcmUgPSByb3V0ZTIuZGF0YTtcbiAgICAgICAgICBjb25zdCByZXMgPSBhd2FpdCBtaWRkbGV3YXJlKHtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICBoZWFkZXJzLFxuICAgICAgICAgICAgcGFyYW1zOiByb3V0ZTI/LnBhcmFtcyxcbiAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgcXVlcnksXG4gICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgIC4uLmNvbmZpZz8uZXh0cmFDb250ZXh0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKHJlcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzPy5fZmxhZyA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkocmVzKSwge1xuICAgICAgICAgICAgICBoZWFkZXJzOiByZXMuaGVhZGVyc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgICAgIG1pZGRsZXdhcmVDb250ZXh0ID0ge1xuICAgICAgICAgICAgICAuLi5yZXMsXG4gICAgICAgICAgICAgIC4uLm1pZGRsZXdhcmVDb250ZXh0XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgaGFuZGxlclJlcyA9IGF3YWl0IGhhbmRsZXIyKHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBwYXJhbXM6IHJvdXRlPy5wYXJhbXMsXG4gICAgICAgIHJlcXVlc3QsXG4gICAgICAgIGJvZHksXG4gICAgICAgIHF1ZXJ5LFxuICAgICAgICBfZmxhZzogXCJyb3V0ZXJcIixcbiAgICAgICAgY29udGV4dDoge1xuICAgICAgICAgIC4uLm1pZGRsZXdhcmVDb250ZXh0LFxuICAgICAgICAgIC4uLmNvbmZpZz8uZXh0cmFDb250ZXh0XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKGhhbmRsZXJSZXMgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xuICAgICAgICByZXR1cm4gaGFuZGxlclJlcztcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc0JvZHkgPSBzaG91bGRTZXJpYWxpemUoaGFuZGxlclJlcykgPyBKU09OLnN0cmluZ2lmeShoYW5kbGVyUmVzKSA6IGhhbmRsZXJSZXM7XG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHJlc0JvZHksIHtcbiAgICAgICAgaGVhZGVyczogaGFuZGxlcjIuaGVhZGVyc1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaWYgKGNvbmZpZz8ub25FcnJvcikge1xuICAgICAgICBjb25zdCBvbkVycm9yUmVzID0gYXdhaXQgY29uZmlnLm9uRXJyb3IoZSk7XG4gICAgICAgIGlmIChvbkVycm9yUmVzIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgICByZXR1cm4gb25FcnJvclJlcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGUgaW5zdGFuY2VvZiBBUElFcnJvcikge1xuICAgICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKGUuYm9keSA/IEpTT04uc3RyaW5naWZ5KGUuYm9keSkgOiBudWxsLCB7XG4gICAgICAgICAgc3RhdHVzOiBzdGF0dXNDb2RlW2Uuc3RhdHVzXSxcbiAgICAgICAgICBzdGF0dXNUZXh0OiBlLnN0YXR1cyxcbiAgICAgICAgICBoZWFkZXJzOiBlLmhlYWRlcnNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoY29uZmlnPy50aHJvd0Vycm9yKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtcbiAgICAgICAgc3RhdHVzOiA1MDAsXG4gICAgICAgIHN0YXR1c1RleHQ6IFwiSW50ZXJuYWwgU2VydmVyIEVycm9yXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBoYW5kbGVyOiBhc3luYyAocmVxdWVzdCkgPT4ge1xuICAgICAgY29uc3Qgb25SZXEgPSBhd2FpdCBjb25maWc/Lm9uUmVxdWVzdD8uKHJlcXVlc3QpO1xuICAgICAgaWYgKG9uUmVxIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIG9uUmVxO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVxID0gb25SZXEgaW5zdGFuY2VvZiBSZXF1ZXN0ID8gb25SZXEgOiByZXF1ZXN0O1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgaGFuZGxlcihyZXEpO1xuICAgICAgY29uc3Qgb25SZXMgPSBhd2FpdCBjb25maWc/Lm9uUmVzcG9uc2U/LihyZXMpO1xuICAgICAgaWYgKG9uUmVzIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIG9uUmVzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcztcbiAgICB9LFxuICAgIGVuZHBvaW50c1xuICB9O1xufTtcblxuLy8gc3JjL21pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIGNyZWF0ZU1pZGRsZXdhcmUob3B0aW9uc09ySGFuZGxlciwgaGFuZGxlcikge1xuICBpZiAodHlwZW9mIG9wdGlvbnNPckhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIHJldHVybiBjcmVhdGVFbmRwb2ludChcbiAgICAgIFwiKlwiLFxuICAgICAge1xuICAgICAgICBtZXRob2Q6IFwiKlwiXG4gICAgICB9LFxuICAgICAgb3B0aW9uc09ySGFuZGxlclxuICAgICk7XG4gIH1cbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTWlkZGxld2FyZSBoYW5kbGVyIGlzIHJlcXVpcmVkXCIpO1xuICB9XG4gIGNvbnN0IGVuZHBvaW50ID0gY3JlYXRlRW5kcG9pbnQoXG4gICAgXCIqXCIsXG4gICAge1xuICAgICAgLi4ub3B0aW9uc09ySGFuZGxlcixcbiAgICAgIG1ldGhvZDogXCIqXCJcbiAgICB9LFxuICAgIGhhbmRsZXJcbiAgKTtcbiAgcmV0dXJuIGVuZHBvaW50O1xufVxudmFyIGNyZWF0ZU1pZGRsZXdhcmVDcmVhdG9yID0gKG9wdHMpID0+IHtcbiAgZnVuY3Rpb24gZm4ob3B0aW9uc09ySGFuZGxlciwgaGFuZGxlcikge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9uc09ySGFuZGxlciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRW5kcG9pbnQoXG4gICAgICAgIFwiKlwiLFxuICAgICAgICB7XG4gICAgICAgICAgbWV0aG9kOiBcIipcIlxuICAgICAgICB9LFxuICAgICAgICBvcHRpb25zT3JIYW5kbGVyXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIWhhbmRsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk1pZGRsZXdhcmUgaGFuZGxlciBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgY29uc3QgZW5kcG9pbnQgPSBjcmVhdGVFbmRwb2ludChcbiAgICAgIFwiKlwiLFxuICAgICAge1xuICAgICAgICAuLi5vcHRpb25zT3JIYW5kbGVyLFxuICAgICAgICBtZXRob2Q6IFwiKlwiXG4gICAgICB9LFxuICAgICAgaGFuZGxlclxuICAgICk7XG4gICAgcmV0dXJuIGVuZHBvaW50O1xuICB9XG4gIHJldHVybiBmbjtcbn07XG5cbi8vIHNyYy90eXBlcy50c1xuaW1wb3J0IFwiem9kXCI7XG5cbi8vIHNyYy9hZGFwdGVyL3JlcXVlc3QudHNcbnZhciBzZXRfY29va2llX3BhcnNlciA9IF9fdG9FU00ocmVxdWlyZV9zZXRfY29va2llKCksIDEpO1xuZnVuY3Rpb24gZ2V0X3Jhd19ib2R5KHJlcSwgYm9keV9zaXplX2xpbWl0KSB7XG4gIGNvbnN0IGggPSByZXEuaGVhZGVycztcbiAgaWYgKCFoW1wiY29udGVudC10eXBlXCJdKSByZXR1cm4gbnVsbDtcbiAgY29uc3QgY29udGVudF9sZW5ndGggPSBOdW1iZXIoaFtcImNvbnRlbnQtbGVuZ3RoXCJdKTtcbiAgaWYgKHJlcS5odHRwVmVyc2lvbk1ham9yID09PSAxICYmIGlzTmFOKGNvbnRlbnRfbGVuZ3RoKSAmJiBoW1widHJhbnNmZXItZW5jb2RpbmdcIl0gPT0gbnVsbCB8fCBjb250ZW50X2xlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGxldCBsZW5ndGggPSBjb250ZW50X2xlbmd0aDtcbiAgaWYgKGJvZHlfc2l6ZV9saW1pdCkge1xuICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICBsZW5ndGggPSBib2R5X3NpemVfbGltaXQ7XG4gICAgfSBlbHNlIGlmIChsZW5ndGggPiBib2R5X3NpemVfbGltaXQpIHtcbiAgICAgIHRocm93IEVycm9yKFxuICAgICAgICBgUmVjZWl2ZWQgY29udGVudC1sZW5ndGggb2YgJHtsZW5ndGh9LCBidXQgb25seSBhY2NlcHQgdXAgdG8gJHtib2R5X3NpemVfbGltaXR9IGJ5dGVzLmBcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChyZXEuZGVzdHJveWVkKSB7XG4gICAgY29uc3QgcmVhZGFibGUgPSBuZXcgUmVhZGFibGVTdHJlYW0oKTtcbiAgICByZWFkYWJsZS5jYW5jZWwoKTtcbiAgICByZXR1cm4gcmVhZGFibGU7XG4gIH1cbiAgbGV0IHNpemUgPSAwO1xuICBsZXQgY2FuY2VsbGVkID0gZmFsc2U7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIHJlcS5vbihcImVycm9yXCIsIChlcnJvcikgPT4ge1xuICAgICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgIH0pO1xuICAgICAgcmVxLm9uKFwiZW5kXCIsICgpID0+IHtcbiAgICAgICAgaWYgKGNhbmNlbGxlZCkgcmV0dXJuO1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9KTtcbiAgICAgIHJlcS5vbihcImRhdGFcIiwgKGNodW5rKSA9PiB7XG4gICAgICAgIGlmIChjYW5jZWxsZWQpIHJldHVybjtcbiAgICAgICAgc2l6ZSArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIGlmIChzaXplID4gbGVuZ3RoKSB7XG4gICAgICAgICAgY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICBjb250cm9sbGVyLmVycm9yKFxuICAgICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgcmVxdWVzdCBib2R5IHNpemUgZXhjZWVkZWQgJHtjb250ZW50X2xlbmd0aCA/IFwiJ2NvbnRlbnQtbGVuZ3RoJ1wiIDogXCJCT0RZX1NJWkVfTElNSVRcIn0gb2YgJHtsZW5ndGh9YFxuICAgICAgICAgICAgKVxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgIGlmIChjb250cm9sbGVyLmRlc2lyZWRTaXplID09PSBudWxsIHx8IGNvbnRyb2xsZXIuZGVzaXJlZFNpemUgPD0gMCkge1xuICAgICAgICAgIHJlcS5wYXVzZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuICAgIHB1bGwoKSB7XG4gICAgICByZXEucmVzdW1lKCk7XG4gICAgfSxcbiAgICBjYW5jZWwocmVhc29uKSB7XG4gICAgICBjYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgcmVxLmRlc3Ryb3kocmVhc29uKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0UmVxdWVzdCh7XG4gIHJlcXVlc3QsXG4gIGJhc2UsXG4gIGJvZHlTaXplTGltaXRcbn0pIHtcbiAgcmV0dXJuIG5ldyBSZXF1ZXN0KGJhc2UgKyByZXF1ZXN0LnVybCwge1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBkdXBsZXg6IFwiaGFsZlwiLFxuICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgYm9keTogZ2V0X3Jhd19ib2R5KHJlcXVlc3QsIGJvZHlTaXplTGltaXQpLFxuICAgIGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVyc1xuICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNldFJlc3BvbnNlKHJlcywgcmVzcG9uc2UpIHtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgcmVzcG9uc2UuaGVhZGVycykge1xuICAgIHRyeSB7XG4gICAgICByZXMuc2V0SGVhZGVyKFxuICAgICAgICBrZXksXG4gICAgICAgIGtleSA9PT0gXCJzZXQtY29va2llXCIgPyBzZXRfY29va2llX3BhcnNlci5zcGxpdENvb2tpZXNTdHJpbmcocmVzcG9uc2UuaGVhZGVycy5nZXQoa2V5KSkgOiB2YWx1ZVxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcmVzLmdldEhlYWRlck5hbWVzKCkuZm9yRWFjaCgobmFtZSkgPT4gcmVzLnJlbW92ZUhlYWRlcihuYW1lKSk7XG4gICAgICByZXMud3JpdGVIZWFkKDUwMCkuZW5kKFN0cmluZyhlcnJvcikpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuICByZXMud3JpdGVIZWFkKHJlc3BvbnNlLnN0YXR1cyk7XG4gIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgIHJlcy5lbmQoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHJlc3BvbnNlLmJvZHkubG9ja2VkKSB7XG4gICAgcmVzLmVuZChcbiAgICAgIFwiRmF0YWwgZXJyb3I6IFJlc3BvbnNlIGJvZHkgaXMgbG9ja2VkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiB0aGUgcmVzcG9uc2Ugd2FzIGFscmVhZHkgcmVhZCAoZm9yIGV4YW1wbGUgdGhyb3VnaCAncmVzcG9uc2UuanNvbigpJyBvciAncmVzcG9uc2UudGV4dCgpJykuXCJcbiAgICApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICBpZiAocmVzLmRlc3Ryb3llZCkge1xuICAgIHJlYWRlci5jYW5jZWwoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgY2FuY2VsID0gKGVycm9yKSA9PiB7XG4gICAgcmVzLm9mZihcImNsb3NlXCIsIGNhbmNlbCk7XG4gICAgcmVzLm9mZihcImVycm9yXCIsIGNhbmNlbCk7XG4gICAgcmVhZGVyLmNhbmNlbChlcnJvcikuY2F0Y2goKCkgPT4ge1xuICAgIH0pO1xuICAgIGlmIChlcnJvcikgcmVzLmRlc3Ryb3koZXJyb3IpO1xuICB9O1xuICByZXMub24oXCJjbG9zZVwiLCBjYW5jZWwpO1xuICByZXMub24oXCJlcnJvclwiLCBjYW5jZWwpO1xuICBuZXh0KCk7XG4gIGFzeW5jIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGZvciAoOyA7ICkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSkgYnJlYWs7XG4gICAgICAgIGlmICghcmVzLndyaXRlKHZhbHVlKSkge1xuICAgICAgICAgIHJlcy5vbmNlKFwiZHJhaW5cIiwgbmV4dCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXMuZW5kKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNhbmNlbChlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yKSkpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvYWRhcHRlci9ub2RlLnRzXG5mdW5jdGlvbiB0b05vZGVIYW5kbGVyKGhhbmRsZXIpIHtcbiAgcmV0dXJuIGFzeW5jIChyZXEsIHJlcykgPT4ge1xuICAgIGNvbnN0IHByb3RvY29sID0gcmVxLmhlYWRlcnNbXCJ4LWZvcndhcmRlZC1wcm90b1wiXSB8fCAocmVxLnNvY2tldC5lbmNyeXB0ZWQgPyBcImh0dHBzXCIgOiBcImh0dHBcIik7XG4gICAgY29uc3QgYmFzZSA9IGAke3Byb3RvY29sfTovLyR7cmVxLmhlYWRlcnNbXCI6YXV0aG9yaXR5XCJdIHx8IHJlcS5oZWFkZXJzLmhvc3R9YDtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGhhbmRsZXIoZ2V0UmVxdWVzdCh7IGJhc2UsIHJlcXVlc3Q6IHJlcSB9KSk7XG4gICAgc2V0UmVzcG9uc2UocmVzLCByZXNwb25zZSk7XG4gIH07XG59XG5leHBvcnQge1xuICBBUElFcnJvcixcbiAgY3JlYXRlRW5kcG9pbnQsXG4gIGNyZWF0ZUVuZHBvaW50Q3JlYXRvcixcbiAgY3JlYXRlTWlkZGxld2FyZSxcbiAgY3JlYXRlTWlkZGxld2FyZUNyZWF0b3IsXG4gIGNyZWF0ZVJvdXRlcixcbiAgZ2V0Qm9keSxcbiAgZ2V0Q29va2llLFxuICBnZXRSZXF1ZXN0LFxuICBnZXRTaWduZWRDb29raWUsXG4gIGpzb24sXG4gIHBhcnNlLFxuICBwYXJzZVNpZ25lZCxcbiAgc2VyaWFsaXplLFxuICBzZXJpYWxpemVTaWduZWQsXG4gIHNldENvb2tpZSxcbiAgc2V0UmVzcG9uc2UsXG4gIHNldFNpZ25lZENvb2tpZSxcbiAgc2hvdWxkU2VyaWFsaXplLFxuICBzaWduQ29va2llVmFsdWUsXG4gIHN0YXR1c0NvZGUsXG4gIHRvTm9kZUhhbmRsZXJcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/better-call@0.3.3/node_modules/better-call/dist/index.js\n");

/***/ })

};
;