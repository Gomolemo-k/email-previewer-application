"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rou3@0.5.1";
exports.ids = ["vendor-chunks/rou3@0.5.1"];
exports.modules = {

/***/ "(action-browser)/./node_modules/.pnpm/rou3@0.5.1/node_modules/rou3/dist/index.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/rou3@0.5.1/node_modules/rou3/dist/index.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addRoute: () => (/* binding */ addRoute),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   findAllRoutes: () => (/* binding */ findAllRoutes),\n/* harmony export */   findRoute: () => (/* binding */ findRoute),\n/* harmony export */   removeRoute: () => (/* binding */ removeRoute)\n/* harmony export */ });\nconst EmptyObject = /* @__PURE__ */ (() => {\n  const C = function() {\n  };\n  C.prototype = /* @__PURE__ */ Object.create(null);\n  return C;\n})();\n\nfunction createRouter() {\n  const ctx = {\n    root: { key: \"\" },\n    static: new EmptyObject()\n  };\n  return ctx;\n}\n\nfunction splitPath(path) {\n  return path.split(\"/\").filter(Boolean);\n}\nfunction getMatchParams(segments, paramsMap) {\n  const params = new EmptyObject();\n  for (const [index, name] of paramsMap) {\n    const segment = index < 0 ? segments.slice(-1 * index).join(\"/\") : segments[index];\n    if (typeof name === \"string\") {\n      params[name] = segment;\n    } else {\n      const match = segment.match(name);\n      if (match) {\n        for (const key in match.groups) {\n          params[key] = match.groups[key];\n        }\n      }\n    }\n  }\n  return params;\n}\n\nfunction addRoute(ctx, method = \"\", path, data) {\n  const segments = splitPath(path);\n  let node = ctx.root;\n  let _unnamedParamIndex = 0;\n  const paramsMap = [];\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    if (segment.startsWith(\"**\")) {\n      if (!node.wildcard) {\n        node.wildcard = { key: \"**\" };\n      }\n      node = node.wildcard;\n      paramsMap.push([\n        -i,\n        segment.split(\":\")[1] || \"_\",\n        segment.length === 2\n      ]);\n      break;\n    }\n    if (segment === \"*\" || segment.includes(\":\")) {\n      if (!node.param) {\n        node.param = { key: \"*\" };\n      }\n      node = node.param;\n      const isOptional = segment === \"*\";\n      paramsMap.push([\n        i,\n        isOptional ? `_${_unnamedParamIndex++}` : _getParamMatcher(segment),\n        isOptional\n      ]);\n      continue;\n    }\n    const child = node.static?.[segment];\n    if (child) {\n      node = child;\n    } else {\n      const staticNode = { key: segment };\n      if (!node.static) {\n        node.static = new EmptyObject();\n      }\n      node.static[segment] = staticNode;\n      node = staticNode;\n    }\n  }\n  const hasParams = paramsMap.length > 0;\n  if (!node.methods) {\n    node.methods = new EmptyObject();\n  }\n  if (!node.methods[method]) {\n    node.methods[method] = [];\n  }\n  node.methods[method].push({\n    data: data || null,\n    paramsMap: hasParams ? paramsMap : void 0\n  });\n  if (!hasParams) {\n    ctx.static[path] = node;\n  }\n}\nfunction _getParamMatcher(segment) {\n  if (!segment.includes(\":\", 1)) {\n    return segment.slice(1);\n  }\n  const regex = segment.replace(/:(\\w+)/g, (_, id) => `(?<${id}>\\\\w+)`);\n  return new RegExp(`^${regex}$`);\n}\n\nfunction findRoute(ctx, method = \"\", path, opts) {\n  if (path[path.length - 1] === \"/\") {\n    path = path.slice(0, -1);\n  }\n  const staticNode = ctx.static[path];\n  if (staticNode && staticNode.methods) {\n    const staticMatch = staticNode.methods[method] || staticNode.methods[\"\"];\n    if (staticMatch !== void 0) {\n      return staticMatch[0];\n    }\n  }\n  const segments = splitPath(path);\n  const match = _lookupTree(ctx, ctx.root, method, segments, 0)?.[0];\n  if (match === void 0) {\n    return;\n  }\n  if (opts?.params === false) {\n    return match;\n  }\n  return {\n    data: match.data,\n    params: match.paramsMap ? getMatchParams(segments, match.paramsMap) : void 0\n  };\n}\nfunction _lookupTree(ctx, node, method, segments, index) {\n  if (index === segments.length) {\n    if (node.methods) {\n      const match = node.methods[method] || node.methods[\"\"];\n      if (match) {\n        return match;\n      }\n    }\n    if (node.param && node.param.methods) {\n      const match = node.param.methods[method] || node.param.methods[\"\"];\n      if (match) {\n        const pMap = match[0].paramsMap;\n        if (pMap?.[pMap?.length - 1]?.[2]) {\n          return match;\n        }\n      }\n    }\n    if (node.wildcard && node.wildcard.methods) {\n      const match = node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n      if (match) {\n        const pMap = match[0].paramsMap;\n        if (pMap?.[pMap?.length - 1]?.[2]) {\n          return match;\n        }\n      }\n    }\n    return void 0;\n  }\n  const segment = segments[index];\n  if (node.static) {\n    const staticChild = node.static[segment];\n    if (staticChild) {\n      const match = _lookupTree(ctx, staticChild, method, segments, index + 1);\n      if (match) {\n        return match;\n      }\n    }\n  }\n  if (node.param) {\n    const match = _lookupTree(ctx, node.param, method, segments, index + 1);\n    if (match) {\n      return match;\n    }\n  }\n  if (node.wildcard && node.wildcard.methods) {\n    return node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n  }\n  return;\n}\n\nfunction removeRoute(ctx, method, path) {\n  const segments = splitPath(path);\n  return _remove(ctx.root, method || \"\", segments, 0);\n}\nfunction _remove(node, method, segments, index) {\n  if (index === segments.length) {\n    if (node.methods && method in node.methods) {\n      delete node.methods[method];\n      if (Object.keys(node.methods).length === 0) {\n        node.methods = void 0;\n      }\n    }\n    return;\n  }\n  const segment = segments[index];\n  if (segment === \"*\") {\n    if (node.param) {\n      _remove(node.param, method, segments, index + 1);\n      if (_isEmptyNode(node.param)) {\n        node.param = void 0;\n      }\n    }\n    return;\n  }\n  if (segment === \"**\") {\n    if (node.wildcard) {\n      _remove(node.wildcard, method, segments, index + 1);\n      if (_isEmptyNode(node.wildcard)) {\n        node.wildcard = void 0;\n      }\n    }\n    return;\n  }\n  const childNode = node.static?.[segment];\n  if (childNode) {\n    _remove(childNode, method, segments, index + 1);\n    if (_isEmptyNode(childNode)) {\n      delete node.static[segment];\n      if (Object.keys(node.static).length === 0) {\n        node.static = void 0;\n      }\n    }\n  }\n}\nfunction _isEmptyNode(node) {\n  return node.methods === void 0 && node.static === void 0 && node.param === void 0 && node.wildcard === void 0;\n}\n\nfunction findAllRoutes(ctx, method = \"\", path, opts) {\n  if (path[path.length - 1] === \"/\") {\n    path = path.slice(0, -1);\n  }\n  const segments = splitPath(path);\n  const matches = _findAll(ctx, ctx.root, method, segments, 0);\n  if (opts?.params === false) {\n    return matches;\n  }\n  return matches.map((m) => {\n    return {\n      data: m.data,\n      params: m.paramsMap ? getMatchParams(segments, m.paramsMap) : void 0\n    };\n  });\n}\nfunction _findAll(ctx, node, method, segments, index, matches = []) {\n  const segment = segments[index];\n  if (node.wildcard && node.wildcard.methods) {\n    const match = node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n    if (match) {\n      matches.push(...match);\n    }\n  }\n  if (node.param) {\n    _findAll(ctx, node.param, method, segments, index + 1, matches);\n    if (index === segments.length && node.param.methods) {\n      const match = node.param.methods[method] || node.param.methods[\"\"];\n      if (match) {\n        matches.push(...match);\n      }\n    }\n  }\n  const staticChild = node.static?.[segment];\n  if (staticChild) {\n    _findAll(ctx, staticChild, method, segments, index + 1, matches);\n  }\n  if (index === segments.length && node.methods) {\n    const match = node.methods[method] || node.methods[\"\"];\n    if (match) {\n      matches.push(...match);\n    }\n  }\n  return matches;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFjdGlvbi1icm93c2VyKS8uL25vZGVfbW9kdWxlcy8ucG5wbS9yb3UzQDAuNS4xL25vZGVfbW9kdWxlcy9yb3UzL2Rpc3QvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixxQkFBcUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxHQUFHO0FBQy9ELHdCQUF3QixNQUFNO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlFIiwic291cmNlcyI6WyIvVXNlcnMvZ29tb2xlbW9rZ2F0aXRzb2UvcHJvamVjdHMvZW1haWwtcHJldmlld2VyLWFwcGxpY2F0aW9uL25vZGVfbW9kdWxlcy8ucG5wbS9yb3UzQDAuNS4xL25vZGVfbW9kdWxlcy9yb3UzL2Rpc3QvaW5kZXgubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEVtcHR5T2JqZWN0ID0gLyogQF9fUFVSRV9fICovICgoKSA9PiB7XG4gIGNvbnN0IEMgPSBmdW5jdGlvbigpIHtcbiAgfTtcbiAgQy5wcm90b3R5cGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIEM7XG59KSgpO1xuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXIoKSB7XG4gIGNvbnN0IGN0eCA9IHtcbiAgICByb290OiB7IGtleTogXCJcIiB9LFxuICAgIHN0YXRpYzogbmV3IEVtcHR5T2JqZWN0KClcbiAgfTtcbiAgcmV0dXJuIGN0eDtcbn1cblxuZnVuY3Rpb24gc3BsaXRQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguc3BsaXQoXCIvXCIpLmZpbHRlcihCb29sZWFuKTtcbn1cbmZ1bmN0aW9uIGdldE1hdGNoUGFyYW1zKHNlZ21lbnRzLCBwYXJhbXNNYXApIHtcbiAgY29uc3QgcGFyYW1zID0gbmV3IEVtcHR5T2JqZWN0KCk7XG4gIGZvciAoY29uc3QgW2luZGV4LCBuYW1lXSBvZiBwYXJhbXNNYXApIHtcbiAgICBjb25zdCBzZWdtZW50ID0gaW5kZXggPCAwID8gc2VnbWVudHMuc2xpY2UoLTEgKiBpbmRleCkuam9pbihcIi9cIikgOiBzZWdtZW50c1tpbmRleF07XG4gICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBwYXJhbXNbbmFtZV0gPSBzZWdtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBtYXRjaCA9IHNlZ21lbnQubWF0Y2gobmFtZSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbWF0Y2guZ3JvdXBzKSB7XG4gICAgICAgICAgcGFyYW1zW2tleV0gPSBtYXRjaC5ncm91cHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcGFyYW1zO1xufVxuXG5mdW5jdGlvbiBhZGRSb3V0ZShjdHgsIG1ldGhvZCA9IFwiXCIsIHBhdGgsIGRhdGEpIHtcbiAgY29uc3Qgc2VnbWVudHMgPSBzcGxpdFBhdGgocGF0aCk7XG4gIGxldCBub2RlID0gY3R4LnJvb3Q7XG4gIGxldCBfdW5uYW1lZFBhcmFtSW5kZXggPSAwO1xuICBjb25zdCBwYXJhbXNNYXAgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcbiAgICBpZiAoc2VnbWVudC5zdGFydHNXaXRoKFwiKipcIikpIHtcbiAgICAgIGlmICghbm9kZS53aWxkY2FyZCkge1xuICAgICAgICBub2RlLndpbGRjYXJkID0geyBrZXk6IFwiKipcIiB9O1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGUud2lsZGNhcmQ7XG4gICAgICBwYXJhbXNNYXAucHVzaChbXG4gICAgICAgIC1pLFxuICAgICAgICBzZWdtZW50LnNwbGl0KFwiOlwiKVsxXSB8fCBcIl9cIixcbiAgICAgICAgc2VnbWVudC5sZW5ndGggPT09IDJcbiAgICAgIF0pO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChzZWdtZW50ID09PSBcIipcIiB8fCBzZWdtZW50LmluY2x1ZGVzKFwiOlwiKSkge1xuICAgICAgaWYgKCFub2RlLnBhcmFtKSB7XG4gICAgICAgIG5vZGUucGFyYW0gPSB7IGtleTogXCIqXCIgfTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnBhcmFtO1xuICAgICAgY29uc3QgaXNPcHRpb25hbCA9IHNlZ21lbnQgPT09IFwiKlwiO1xuICAgICAgcGFyYW1zTWFwLnB1c2goW1xuICAgICAgICBpLFxuICAgICAgICBpc09wdGlvbmFsID8gYF8ke191bm5hbWVkUGFyYW1JbmRleCsrfWAgOiBfZ2V0UGFyYW1NYXRjaGVyKHNlZ21lbnQpLFxuICAgICAgICBpc09wdGlvbmFsXG4gICAgICBdKTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZCA9IG5vZGUuc3RhdGljPy5bc2VnbWVudF07XG4gICAgaWYgKGNoaWxkKSB7XG4gICAgICBub2RlID0gY2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHN0YXRpY05vZGUgPSB7IGtleTogc2VnbWVudCB9O1xuICAgICAgaWYgKCFub2RlLnN0YXRpYykge1xuICAgICAgICBub2RlLnN0YXRpYyA9IG5ldyBFbXB0eU9iamVjdCgpO1xuICAgICAgfVxuICAgICAgbm9kZS5zdGF0aWNbc2VnbWVudF0gPSBzdGF0aWNOb2RlO1xuICAgICAgbm9kZSA9IHN0YXRpY05vZGU7XG4gICAgfVxuICB9XG4gIGNvbnN0IGhhc1BhcmFtcyA9IHBhcmFtc01hcC5sZW5ndGggPiAwO1xuICBpZiAoIW5vZGUubWV0aG9kcykge1xuICAgIG5vZGUubWV0aG9kcyA9IG5ldyBFbXB0eU9iamVjdCgpO1xuICB9XG4gIGlmICghbm9kZS5tZXRob2RzW21ldGhvZF0pIHtcbiAgICBub2RlLm1ldGhvZHNbbWV0aG9kXSA9IFtdO1xuICB9XG4gIG5vZGUubWV0aG9kc1ttZXRob2RdLnB1c2goe1xuICAgIGRhdGE6IGRhdGEgfHwgbnVsbCxcbiAgICBwYXJhbXNNYXA6IGhhc1BhcmFtcyA/IHBhcmFtc01hcCA6IHZvaWQgMFxuICB9KTtcbiAgaWYgKCFoYXNQYXJhbXMpIHtcbiAgICBjdHguc3RhdGljW3BhdGhdID0gbm9kZTtcbiAgfVxufVxuZnVuY3Rpb24gX2dldFBhcmFtTWF0Y2hlcihzZWdtZW50KSB7XG4gIGlmICghc2VnbWVudC5pbmNsdWRlcyhcIjpcIiwgMSkpIHtcbiAgICByZXR1cm4gc2VnbWVudC5zbGljZSgxKTtcbiAgfVxuICBjb25zdCByZWdleCA9IHNlZ21lbnQucmVwbGFjZSgvOihcXHcrKS9nLCAoXywgaWQpID0+IGAoPzwke2lkfT5cXFxcdyspYCk7XG4gIHJldHVybiBuZXcgUmVnRXhwKGBeJHtyZWdleH0kYCk7XG59XG5cbmZ1bmN0aW9uIGZpbmRSb3V0ZShjdHgsIG1ldGhvZCA9IFwiXCIsIHBhdGgsIG9wdHMpIHtcbiAgaWYgKHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gXCIvXCIpIHtcbiAgICBwYXRoID0gcGF0aC5zbGljZSgwLCAtMSk7XG4gIH1cbiAgY29uc3Qgc3RhdGljTm9kZSA9IGN0eC5zdGF0aWNbcGF0aF07XG4gIGlmIChzdGF0aWNOb2RlICYmIHN0YXRpY05vZGUubWV0aG9kcykge1xuICAgIGNvbnN0IHN0YXRpY01hdGNoID0gc3RhdGljTm9kZS5tZXRob2RzW21ldGhvZF0gfHwgc3RhdGljTm9kZS5tZXRob2RzW1wiXCJdO1xuICAgIGlmIChzdGF0aWNNYXRjaCAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gc3RhdGljTWF0Y2hbMF07XG4gICAgfVxuICB9XG4gIGNvbnN0IHNlZ21lbnRzID0gc3BsaXRQYXRoKHBhdGgpO1xuICBjb25zdCBtYXRjaCA9IF9sb29rdXBUcmVlKGN0eCwgY3R4LnJvb3QsIG1ldGhvZCwgc2VnbWVudHMsIDApPy5bMF07XG4gIGlmIChtYXRjaCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChvcHRzPy5wYXJhbXMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG1hdGNoO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGF0YTogbWF0Y2guZGF0YSxcbiAgICBwYXJhbXM6IG1hdGNoLnBhcmFtc01hcCA/IGdldE1hdGNoUGFyYW1zKHNlZ21lbnRzLCBtYXRjaC5wYXJhbXNNYXApIDogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiBfbG9va3VwVHJlZShjdHgsIG5vZGUsIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4KSB7XG4gIGlmIChpbmRleCA9PT0gc2VnbWVudHMubGVuZ3RoKSB7XG4gICAgaWYgKG5vZGUubWV0aG9kcykge1xuICAgICAgY29uc3QgbWF0Y2ggPSBub2RlLm1ldGhvZHNbbWV0aG9kXSB8fCBub2RlLm1ldGhvZHNbXCJcIl07XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5wYXJhbSAmJiBub2RlLnBhcmFtLm1ldGhvZHMpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gbm9kZS5wYXJhbS5tZXRob2RzW21ldGhvZF0gfHwgbm9kZS5wYXJhbS5tZXRob2RzW1wiXCJdO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGNvbnN0IHBNYXAgPSBtYXRjaFswXS5wYXJhbXNNYXA7XG4gICAgICAgIGlmIChwTWFwPy5bcE1hcD8ubGVuZ3RoIC0gMV0/LlsyXSkge1xuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS53aWxkY2FyZCAmJiBub2RlLndpbGRjYXJkLm1ldGhvZHMpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gbm9kZS53aWxkY2FyZC5tZXRob2RzW21ldGhvZF0gfHwgbm9kZS53aWxkY2FyZC5tZXRob2RzW1wiXCJdO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGNvbnN0IHBNYXAgPSBtYXRjaFswXS5wYXJhbXNNYXA7XG4gICAgICAgIGlmIChwTWFwPy5bcE1hcD8ubGVuZ3RoIC0gMV0/LlsyXSkge1xuICAgICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpbmRleF07XG4gIGlmIChub2RlLnN0YXRpYykge1xuICAgIGNvbnN0IHN0YXRpY0NoaWxkID0gbm9kZS5zdGF0aWNbc2VnbWVudF07XG4gICAgaWYgKHN0YXRpY0NoaWxkKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IF9sb29rdXBUcmVlKGN0eCwgc3RhdGljQ2hpbGQsIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4ICsgMSk7XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAobm9kZS5wYXJhbSkge1xuICAgIGNvbnN0IG1hdGNoID0gX2xvb2t1cFRyZWUoY3R4LCBub2RlLnBhcmFtLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCArIDEpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH1cbiAgfVxuICBpZiAobm9kZS53aWxkY2FyZCAmJiBub2RlLndpbGRjYXJkLm1ldGhvZHMpIHtcbiAgICByZXR1cm4gbm9kZS53aWxkY2FyZC5tZXRob2RzW21ldGhvZF0gfHwgbm9kZS53aWxkY2FyZC5tZXRob2RzW1wiXCJdO1xuICB9XG4gIHJldHVybjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlUm91dGUoY3R4LCBtZXRob2QsIHBhdGgpIHtcbiAgY29uc3Qgc2VnbWVudHMgPSBzcGxpdFBhdGgocGF0aCk7XG4gIHJldHVybiBfcmVtb3ZlKGN0eC5yb290LCBtZXRob2QgfHwgXCJcIiwgc2VnbWVudHMsIDApO1xufVxuZnVuY3Rpb24gX3JlbW92ZShub2RlLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCkge1xuICBpZiAoaW5kZXggPT09IHNlZ21lbnRzLmxlbmd0aCkge1xuICAgIGlmIChub2RlLm1ldGhvZHMgJiYgbWV0aG9kIGluIG5vZGUubWV0aG9kcykge1xuICAgICAgZGVsZXRlIG5vZGUubWV0aG9kc1ttZXRob2RdO1xuICAgICAgaWYgKE9iamVjdC5rZXlzKG5vZGUubWV0aG9kcykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG5vZGUubWV0aG9kcyA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHNlZ21lbnQgPSBzZWdtZW50c1tpbmRleF07XG4gIGlmIChzZWdtZW50ID09PSBcIipcIikge1xuICAgIGlmIChub2RlLnBhcmFtKSB7XG4gICAgICBfcmVtb3ZlKG5vZGUucGFyYW0sIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4ICsgMSk7XG4gICAgICBpZiAoX2lzRW1wdHlOb2RlKG5vZGUucGFyYW0pKSB7XG4gICAgICAgIG5vZGUucGFyYW0gPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc2VnbWVudCA9PT0gXCIqKlwiKSB7XG4gICAgaWYgKG5vZGUud2lsZGNhcmQpIHtcbiAgICAgIF9yZW1vdmUobm9kZS53aWxkY2FyZCwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXggKyAxKTtcbiAgICAgIGlmIChfaXNFbXB0eU5vZGUobm9kZS53aWxkY2FyZCkpIHtcbiAgICAgICAgbm9kZS53aWxkY2FyZCA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNoaWxkTm9kZSA9IG5vZGUuc3RhdGljPy5bc2VnbWVudF07XG4gIGlmIChjaGlsZE5vZGUpIHtcbiAgICBfcmVtb3ZlKGNoaWxkTm9kZSwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXggKyAxKTtcbiAgICBpZiAoX2lzRW1wdHlOb2RlKGNoaWxkTm9kZSkpIHtcbiAgICAgIGRlbGV0ZSBub2RlLnN0YXRpY1tzZWdtZW50XTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhub2RlLnN0YXRpYykubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIG5vZGUuc3RhdGljID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gX2lzRW1wdHlOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUubWV0aG9kcyA9PT0gdm9pZCAwICYmIG5vZGUuc3RhdGljID09PSB2b2lkIDAgJiYgbm9kZS5wYXJhbSA9PT0gdm9pZCAwICYmIG5vZGUud2lsZGNhcmQgPT09IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gZmluZEFsbFJvdXRlcyhjdHgsIG1ldGhvZCA9IFwiXCIsIHBhdGgsIG9wdHMpIHtcbiAgaWYgKHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gXCIvXCIpIHtcbiAgICBwYXRoID0gcGF0aC5zbGljZSgwLCAtMSk7XG4gIH1cbiAgY29uc3Qgc2VnbWVudHMgPSBzcGxpdFBhdGgocGF0aCk7XG4gIGNvbnN0IG1hdGNoZXMgPSBfZmluZEFsbChjdHgsIGN0eC5yb290LCBtZXRob2QsIHNlZ21lbnRzLCAwKTtcbiAgaWYgKG9wdHM/LnBhcmFtcyA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm4gbWF0Y2hlcztcbiAgfVxuICByZXR1cm4gbWF0Y2hlcy5tYXAoKG0pID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0YTogbS5kYXRhLFxuICAgICAgcGFyYW1zOiBtLnBhcmFtc01hcCA/IGdldE1hdGNoUGFyYW1zKHNlZ21lbnRzLCBtLnBhcmFtc01hcCkgOiB2b2lkIDBcbiAgICB9O1xuICB9KTtcbn1cbmZ1bmN0aW9uIF9maW5kQWxsKGN0eCwgbm9kZSwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXgsIG1hdGNoZXMgPSBbXSkge1xuICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaW5kZXhdO1xuICBpZiAobm9kZS53aWxkY2FyZCAmJiBub2RlLndpbGRjYXJkLm1ldGhvZHMpIHtcbiAgICBjb25zdCBtYXRjaCA9IG5vZGUud2lsZGNhcmQubWV0aG9kc1ttZXRob2RdIHx8IG5vZGUud2lsZGNhcmQubWV0aG9kc1tcIlwiXTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIG1hdGNoZXMucHVzaCguLi5tYXRjaCk7XG4gICAgfVxuICB9XG4gIGlmIChub2RlLnBhcmFtKSB7XG4gICAgX2ZpbmRBbGwoY3R4LCBub2RlLnBhcmFtLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCArIDEsIG1hdGNoZXMpO1xuICAgIGlmIChpbmRleCA9PT0gc2VnbWVudHMubGVuZ3RoICYmIG5vZGUucGFyYW0ubWV0aG9kcykge1xuICAgICAgY29uc3QgbWF0Y2ggPSBub2RlLnBhcmFtLm1ldGhvZHNbbWV0aG9kXSB8fCBub2RlLnBhcmFtLm1ldGhvZHNbXCJcIl07XG4gICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgbWF0Y2hlcy5wdXNoKC4uLm1hdGNoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgY29uc3Qgc3RhdGljQ2hpbGQgPSBub2RlLnN0YXRpYz8uW3NlZ21lbnRdO1xuICBpZiAoc3RhdGljQ2hpbGQpIHtcbiAgICBfZmluZEFsbChjdHgsIHN0YXRpY0NoaWxkLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCArIDEsIG1hdGNoZXMpO1xuICB9XG4gIGlmIChpbmRleCA9PT0gc2VnbWVudHMubGVuZ3RoICYmIG5vZGUubWV0aG9kcykge1xuICAgIGNvbnN0IG1hdGNoID0gbm9kZS5tZXRob2RzW21ldGhvZF0gfHwgbm9kZS5tZXRob2RzW1wiXCJdO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgbWF0Y2hlcy5wdXNoKC4uLm1hdGNoKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXM7XG59XG5cbmV4cG9ydCB7IGFkZFJvdXRlLCBjcmVhdGVSb3V0ZXIsIGZpbmRBbGxSb3V0ZXMsIGZpbmRSb3V0ZSwgcmVtb3ZlUm91dGUgfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(action-browser)/./node_modules/.pnpm/rou3@0.5.1/node_modules/rou3/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/rou3@0.5.1/node_modules/rou3/dist/index.mjs":
/*!************************************************************************!*\
  !*** ./node_modules/.pnpm/rou3@0.5.1/node_modules/rou3/dist/index.mjs ***!
  \************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   addRoute: () => (/* binding */ addRoute),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   findAllRoutes: () => (/* binding */ findAllRoutes),\n/* harmony export */   findRoute: () => (/* binding */ findRoute),\n/* harmony export */   removeRoute: () => (/* binding */ removeRoute)\n/* harmony export */ });\nconst EmptyObject = /* @__PURE__ */ (() => {\n  const C = function() {\n  };\n  C.prototype = /* @__PURE__ */ Object.create(null);\n  return C;\n})();\n\nfunction createRouter() {\n  const ctx = {\n    root: { key: \"\" },\n    static: new EmptyObject()\n  };\n  return ctx;\n}\n\nfunction splitPath(path) {\n  return path.split(\"/\").filter(Boolean);\n}\nfunction getMatchParams(segments, paramsMap) {\n  const params = new EmptyObject();\n  for (const [index, name] of paramsMap) {\n    const segment = index < 0 ? segments.slice(-1 * index).join(\"/\") : segments[index];\n    if (typeof name === \"string\") {\n      params[name] = segment;\n    } else {\n      const match = segment.match(name);\n      if (match) {\n        for (const key in match.groups) {\n          params[key] = match.groups[key];\n        }\n      }\n    }\n  }\n  return params;\n}\n\nfunction addRoute(ctx, method = \"\", path, data) {\n  const segments = splitPath(path);\n  let node = ctx.root;\n  let _unnamedParamIndex = 0;\n  const paramsMap = [];\n  for (let i = 0; i < segments.length; i++) {\n    const segment = segments[i];\n    if (segment.startsWith(\"**\")) {\n      if (!node.wildcard) {\n        node.wildcard = { key: \"**\" };\n      }\n      node = node.wildcard;\n      paramsMap.push([\n        -i,\n        segment.split(\":\")[1] || \"_\",\n        segment.length === 2\n      ]);\n      break;\n    }\n    if (segment === \"*\" || segment.includes(\":\")) {\n      if (!node.param) {\n        node.param = { key: \"*\" };\n      }\n      node = node.param;\n      const isOptional = segment === \"*\";\n      paramsMap.push([\n        i,\n        isOptional ? `_${_unnamedParamIndex++}` : _getParamMatcher(segment),\n        isOptional\n      ]);\n      continue;\n    }\n    const child = node.static?.[segment];\n    if (child) {\n      node = child;\n    } else {\n      const staticNode = { key: segment };\n      if (!node.static) {\n        node.static = new EmptyObject();\n      }\n      node.static[segment] = staticNode;\n      node = staticNode;\n    }\n  }\n  const hasParams = paramsMap.length > 0;\n  if (!node.methods) {\n    node.methods = new EmptyObject();\n  }\n  if (!node.methods[method]) {\n    node.methods[method] = [];\n  }\n  node.methods[method].push({\n    data: data || null,\n    paramsMap: hasParams ? paramsMap : void 0\n  });\n  if (!hasParams) {\n    ctx.static[path] = node;\n  }\n}\nfunction _getParamMatcher(segment) {\n  if (!segment.includes(\":\", 1)) {\n    return segment.slice(1);\n  }\n  const regex = segment.replace(/:(\\w+)/g, (_, id) => `(?<${id}>\\\\w+)`);\n  return new RegExp(`^${regex}$`);\n}\n\nfunction findRoute(ctx, method = \"\", path, opts) {\n  if (path[path.length - 1] === \"/\") {\n    path = path.slice(0, -1);\n  }\n  const staticNode = ctx.static[path];\n  if (staticNode && staticNode.methods) {\n    const staticMatch = staticNode.methods[method] || staticNode.methods[\"\"];\n    if (staticMatch !== void 0) {\n      return staticMatch[0];\n    }\n  }\n  const segments = splitPath(path);\n  const match = _lookupTree(ctx, ctx.root, method, segments, 0)?.[0];\n  if (match === void 0) {\n    return;\n  }\n  if (opts?.params === false) {\n    return match;\n  }\n  return {\n    data: match.data,\n    params: match.paramsMap ? getMatchParams(segments, match.paramsMap) : void 0\n  };\n}\nfunction _lookupTree(ctx, node, method, segments, index) {\n  if (index === segments.length) {\n    if (node.methods) {\n      const match = node.methods[method] || node.methods[\"\"];\n      if (match) {\n        return match;\n      }\n    }\n    if (node.param && node.param.methods) {\n      const match = node.param.methods[method] || node.param.methods[\"\"];\n      if (match) {\n        const pMap = match[0].paramsMap;\n        if (pMap?.[pMap?.length - 1]?.[2]) {\n          return match;\n        }\n      }\n    }\n    if (node.wildcard && node.wildcard.methods) {\n      const match = node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n      if (match) {\n        const pMap = match[0].paramsMap;\n        if (pMap?.[pMap?.length - 1]?.[2]) {\n          return match;\n        }\n      }\n    }\n    return void 0;\n  }\n  const segment = segments[index];\n  if (node.static) {\n    const staticChild = node.static[segment];\n    if (staticChild) {\n      const match = _lookupTree(ctx, staticChild, method, segments, index + 1);\n      if (match) {\n        return match;\n      }\n    }\n  }\n  if (node.param) {\n    const match = _lookupTree(ctx, node.param, method, segments, index + 1);\n    if (match) {\n      return match;\n    }\n  }\n  if (node.wildcard && node.wildcard.methods) {\n    return node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n  }\n  return;\n}\n\nfunction removeRoute(ctx, method, path) {\n  const segments = splitPath(path);\n  return _remove(ctx.root, method || \"\", segments, 0);\n}\nfunction _remove(node, method, segments, index) {\n  if (index === segments.length) {\n    if (node.methods && method in node.methods) {\n      delete node.methods[method];\n      if (Object.keys(node.methods).length === 0) {\n        node.methods = void 0;\n      }\n    }\n    return;\n  }\n  const segment = segments[index];\n  if (segment === \"*\") {\n    if (node.param) {\n      _remove(node.param, method, segments, index + 1);\n      if (_isEmptyNode(node.param)) {\n        node.param = void 0;\n      }\n    }\n    return;\n  }\n  if (segment === \"**\") {\n    if (node.wildcard) {\n      _remove(node.wildcard, method, segments, index + 1);\n      if (_isEmptyNode(node.wildcard)) {\n        node.wildcard = void 0;\n      }\n    }\n    return;\n  }\n  const childNode = node.static?.[segment];\n  if (childNode) {\n    _remove(childNode, method, segments, index + 1);\n    if (_isEmptyNode(childNode)) {\n      delete node.static[segment];\n      if (Object.keys(node.static).length === 0) {\n        node.static = void 0;\n      }\n    }\n  }\n}\nfunction _isEmptyNode(node) {\n  return node.methods === void 0 && node.static === void 0 && node.param === void 0 && node.wildcard === void 0;\n}\n\nfunction findAllRoutes(ctx, method = \"\", path, opts) {\n  if (path[path.length - 1] === \"/\") {\n    path = path.slice(0, -1);\n  }\n  const segments = splitPath(path);\n  const matches = _findAll(ctx, ctx.root, method, segments, 0);\n  if (opts?.params === false) {\n    return matches;\n  }\n  return matches.map((m) => {\n    return {\n      data: m.data,\n      params: m.paramsMap ? getMatchParams(segments, m.paramsMap) : void 0\n    };\n  });\n}\nfunction _findAll(ctx, node, method, segments, index, matches = []) {\n  const segment = segments[index];\n  if (node.wildcard && node.wildcard.methods) {\n    const match = node.wildcard.methods[method] || node.wildcard.methods[\"\"];\n    if (match) {\n      matches.push(...match);\n    }\n  }\n  if (node.param) {\n    _findAll(ctx, node.param, method, segments, index + 1, matches);\n    if (index === segments.length && node.param.methods) {\n      const match = node.param.methods[method] || node.param.methods[\"\"];\n      if (match) {\n        matches.push(...match);\n      }\n    }\n  }\n  const staticChild = node.static?.[segment];\n  if (staticChild) {\n    _findAll(ctx, staticChild, method, segments, index + 1, matches);\n  }\n  if (index === segments.length && node.methods) {\n    const match = node.methods[method] || node.methods[\"\"];\n    if (match) {\n      matches.push(...match);\n    }\n  }\n  return matches;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vcm91M0AwLjUuMS9ub2RlX21vZHVsZXMvcm91My9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscUJBQXFCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsR0FBRztBQUMvRCx3QkFBd0IsTUFBTTtBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUV5RSIsInNvdXJjZXMiOlsiL1VzZXJzL2dvbW9sZW1va2dhdGl0c29lL3Byb2plY3RzL2VtYWlsLXByZXZpZXdlci1hcHBsaWNhdGlvbi9ub2RlX21vZHVsZXMvLnBucG0vcm91M0AwLjUuMS9ub2RlX21vZHVsZXMvcm91My9kaXN0L2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBFbXB0eU9iamVjdCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICBjb25zdCBDID0gZnVuY3Rpb24oKSB7XG4gIH07XG4gIEMucHJvdG90eXBlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIHJldHVybiBDO1xufSkoKTtcblxuZnVuY3Rpb24gY3JlYXRlUm91dGVyKCkge1xuICBjb25zdCBjdHggPSB7XG4gICAgcm9vdDogeyBrZXk6IFwiXCIgfSxcbiAgICBzdGF0aWM6IG5ldyBFbXB0eU9iamVjdCgpXG4gIH07XG4gIHJldHVybiBjdHg7XG59XG5cbmZ1bmN0aW9uIHNwbGl0UGF0aChwYXRoKSB7XG4gIHJldHVybiBwYXRoLnNwbGl0KFwiL1wiKS5maWx0ZXIoQm9vbGVhbik7XG59XG5mdW5jdGlvbiBnZXRNYXRjaFBhcmFtcyhzZWdtZW50cywgcGFyYW1zTWFwKSB7XG4gIGNvbnN0IHBhcmFtcyA9IG5ldyBFbXB0eU9iamVjdCgpO1xuICBmb3IgKGNvbnN0IFtpbmRleCwgbmFtZV0gb2YgcGFyYW1zTWFwKSB7XG4gICAgY29uc3Qgc2VnbWVudCA9IGluZGV4IDwgMCA/IHNlZ21lbnRzLnNsaWNlKC0xICogaW5kZXgpLmpvaW4oXCIvXCIpIDogc2VnbWVudHNbaW5kZXhdO1xuICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcGFyYW1zW25hbWVdID0gc2VnbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbWF0Y2ggPSBzZWdtZW50Lm1hdGNoKG5hbWUpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG1hdGNoLmdyb3Vwcykge1xuICAgICAgICAgIHBhcmFtc1trZXldID0gbWF0Y2guZ3JvdXBzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuZnVuY3Rpb24gYWRkUm91dGUoY3R4LCBtZXRob2QgPSBcIlwiLCBwYXRoLCBkYXRhKSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gc3BsaXRQYXRoKHBhdGgpO1xuICBsZXQgbm9kZSA9IGN0eC5yb290O1xuICBsZXQgX3VubmFtZWRQYXJhbUluZGV4ID0gMDtcbiAgY29uc3QgcGFyYW1zTWFwID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgaWYgKHNlZ21lbnQuc3RhcnRzV2l0aChcIioqXCIpKSB7XG4gICAgICBpZiAoIW5vZGUud2lsZGNhcmQpIHtcbiAgICAgICAgbm9kZS53aWxkY2FyZCA9IHsga2V5OiBcIioqXCIgfTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLndpbGRjYXJkO1xuICAgICAgcGFyYW1zTWFwLnB1c2goW1xuICAgICAgICAtaSxcbiAgICAgICAgc2VnbWVudC5zcGxpdChcIjpcIilbMV0gfHwgXCJfXCIsXG4gICAgICAgIHNlZ21lbnQubGVuZ3RoID09PSAyXG4gICAgICBdKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoc2VnbWVudCA9PT0gXCIqXCIgfHwgc2VnbWVudC5pbmNsdWRlcyhcIjpcIikpIHtcbiAgICAgIGlmICghbm9kZS5wYXJhbSkge1xuICAgICAgICBub2RlLnBhcmFtID0geyBrZXk6IFwiKlwiIH07XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5wYXJhbTtcbiAgICAgIGNvbnN0IGlzT3B0aW9uYWwgPSBzZWdtZW50ID09PSBcIipcIjtcbiAgICAgIHBhcmFtc01hcC5wdXNoKFtcbiAgICAgICAgaSxcbiAgICAgICAgaXNPcHRpb25hbCA/IGBfJHtfdW5uYW1lZFBhcmFtSW5kZXgrK31gIDogX2dldFBhcmFtTWF0Y2hlcihzZWdtZW50KSxcbiAgICAgICAgaXNPcHRpb25hbFxuICAgICAgXSk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgY2hpbGQgPSBub2RlLnN0YXRpYz8uW3NlZ21lbnRdO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgbm9kZSA9IGNoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdGF0aWNOb2RlID0geyBrZXk6IHNlZ21lbnQgfTtcbiAgICAgIGlmICghbm9kZS5zdGF0aWMpIHtcbiAgICAgICAgbm9kZS5zdGF0aWMgPSBuZXcgRW1wdHlPYmplY3QoKTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc3RhdGljW3NlZ21lbnRdID0gc3RhdGljTm9kZTtcbiAgICAgIG5vZGUgPSBzdGF0aWNOb2RlO1xuICAgIH1cbiAgfVxuICBjb25zdCBoYXNQYXJhbXMgPSBwYXJhbXNNYXAubGVuZ3RoID4gMDtcbiAgaWYgKCFub2RlLm1ldGhvZHMpIHtcbiAgICBub2RlLm1ldGhvZHMgPSBuZXcgRW1wdHlPYmplY3QoKTtcbiAgfVxuICBpZiAoIW5vZGUubWV0aG9kc1ttZXRob2RdKSB7XG4gICAgbm9kZS5tZXRob2RzW21ldGhvZF0gPSBbXTtcbiAgfVxuICBub2RlLm1ldGhvZHNbbWV0aG9kXS5wdXNoKHtcbiAgICBkYXRhOiBkYXRhIHx8IG51bGwsXG4gICAgcGFyYW1zTWFwOiBoYXNQYXJhbXMgPyBwYXJhbXNNYXAgOiB2b2lkIDBcbiAgfSk7XG4gIGlmICghaGFzUGFyYW1zKSB7XG4gICAgY3R4LnN0YXRpY1twYXRoXSA9IG5vZGU7XG4gIH1cbn1cbmZ1bmN0aW9uIF9nZXRQYXJhbU1hdGNoZXIoc2VnbWVudCkge1xuICBpZiAoIXNlZ21lbnQuaW5jbHVkZXMoXCI6XCIsIDEpKSB7XG4gICAgcmV0dXJuIHNlZ21lbnQuc2xpY2UoMSk7XG4gIH1cbiAgY29uc3QgcmVnZXggPSBzZWdtZW50LnJlcGxhY2UoLzooXFx3KykvZywgKF8sIGlkKSA9PiBgKD88JHtpZH0+XFxcXHcrKWApO1xuICByZXR1cm4gbmV3IFJlZ0V4cChgXiR7cmVnZXh9JGApO1xufVxuXG5mdW5jdGlvbiBmaW5kUm91dGUoY3R4LCBtZXRob2QgPSBcIlwiLCBwYXRoLCBvcHRzKSB7XG4gIGlmIChwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09IFwiL1wiKSB7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgLTEpO1xuICB9XG4gIGNvbnN0IHN0YXRpY05vZGUgPSBjdHguc3RhdGljW3BhdGhdO1xuICBpZiAoc3RhdGljTm9kZSAmJiBzdGF0aWNOb2RlLm1ldGhvZHMpIHtcbiAgICBjb25zdCBzdGF0aWNNYXRjaCA9IHN0YXRpY05vZGUubWV0aG9kc1ttZXRob2RdIHx8IHN0YXRpY05vZGUubWV0aG9kc1tcIlwiXTtcbiAgICBpZiAoc3RhdGljTWF0Y2ggIT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHN0YXRpY01hdGNoWzBdO1xuICAgIH1cbiAgfVxuICBjb25zdCBzZWdtZW50cyA9IHNwbGl0UGF0aChwYXRoKTtcbiAgY29uc3QgbWF0Y2ggPSBfbG9va3VwVHJlZShjdHgsIGN0eC5yb290LCBtZXRob2QsIHNlZ21lbnRzLCAwKT8uWzBdO1xuICBpZiAobWF0Y2ggPT09IHZvaWQgMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAob3B0cz8ucGFyYW1zID09PSBmYWxzZSkge1xuICAgIHJldHVybiBtYXRjaDtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRhdGE6IG1hdGNoLmRhdGEsXG4gICAgcGFyYW1zOiBtYXRjaC5wYXJhbXNNYXAgPyBnZXRNYXRjaFBhcmFtcyhzZWdtZW50cywgbWF0Y2gucGFyYW1zTWFwKSA6IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gX2xvb2t1cFRyZWUoY3R4LCBub2RlLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCkge1xuICBpZiAoaW5kZXggPT09IHNlZ21lbnRzLmxlbmd0aCkge1xuICAgIGlmIChub2RlLm1ldGhvZHMpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gbm9kZS5tZXRob2RzW21ldGhvZF0gfHwgbm9kZS5tZXRob2RzW1wiXCJdO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUucGFyYW0gJiYgbm9kZS5wYXJhbS5tZXRob2RzKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IG5vZGUucGFyYW0ubWV0aG9kc1ttZXRob2RdIHx8IG5vZGUucGFyYW0ubWV0aG9kc1tcIlwiXTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBjb25zdCBwTWFwID0gbWF0Y2hbMF0ucGFyYW1zTWFwO1xuICAgICAgICBpZiAocE1hcD8uW3BNYXA/Lmxlbmd0aCAtIDFdPy5bMl0pIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUud2lsZGNhcmQgJiYgbm9kZS53aWxkY2FyZC5tZXRob2RzKSB7XG4gICAgICBjb25zdCBtYXRjaCA9IG5vZGUud2lsZGNhcmQubWV0aG9kc1ttZXRob2RdIHx8IG5vZGUud2lsZGNhcmQubWV0aG9kc1tcIlwiXTtcbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICBjb25zdCBwTWFwID0gbWF0Y2hbMF0ucGFyYW1zTWFwO1xuICAgICAgICBpZiAocE1hcD8uW3BNYXA/Lmxlbmd0aCAtIDFdPy5bMl0pIHtcbiAgICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaW5kZXhdO1xuICBpZiAobm9kZS5zdGF0aWMpIHtcbiAgICBjb25zdCBzdGF0aWNDaGlsZCA9IG5vZGUuc3RhdGljW3NlZ21lbnRdO1xuICAgIGlmIChzdGF0aWNDaGlsZCkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBfbG9va3VwVHJlZShjdHgsIHN0YXRpY0NoaWxkLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCArIDEpO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHJldHVybiBtYXRjaDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG5vZGUucGFyYW0pIHtcbiAgICBjb25zdCBtYXRjaCA9IF9sb29rdXBUcmVlKGN0eCwgbm9kZS5wYXJhbSwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXggKyAxKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG4gIH1cbiAgaWYgKG5vZGUud2lsZGNhcmQgJiYgbm9kZS53aWxkY2FyZC5tZXRob2RzKSB7XG4gICAgcmV0dXJuIG5vZGUud2lsZGNhcmQubWV0aG9kc1ttZXRob2RdIHx8IG5vZGUud2lsZGNhcmQubWV0aG9kc1tcIlwiXTtcbiAgfVxuICByZXR1cm47XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVJvdXRlKGN0eCwgbWV0aG9kLCBwYXRoKSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gc3BsaXRQYXRoKHBhdGgpO1xuICByZXR1cm4gX3JlbW92ZShjdHgucm9vdCwgbWV0aG9kIHx8IFwiXCIsIHNlZ21lbnRzLCAwKTtcbn1cbmZ1bmN0aW9uIF9yZW1vdmUobm9kZSwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXgpIHtcbiAgaWYgKGluZGV4ID09PSBzZWdtZW50cy5sZW5ndGgpIHtcbiAgICBpZiAobm9kZS5tZXRob2RzICYmIG1ldGhvZCBpbiBub2RlLm1ldGhvZHMpIHtcbiAgICAgIGRlbGV0ZSBub2RlLm1ldGhvZHNbbWV0aG9kXTtcbiAgICAgIGlmIChPYmplY3Qua2V5cyhub2RlLm1ldGhvZHMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBub2RlLm1ldGhvZHMgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzZWdtZW50ID0gc2VnbWVudHNbaW5kZXhdO1xuICBpZiAoc2VnbWVudCA9PT0gXCIqXCIpIHtcbiAgICBpZiAobm9kZS5wYXJhbSkge1xuICAgICAgX3JlbW92ZShub2RlLnBhcmFtLCBtZXRob2QsIHNlZ21lbnRzLCBpbmRleCArIDEpO1xuICAgICAgaWYgKF9pc0VtcHR5Tm9kZShub2RlLnBhcmFtKSkge1xuICAgICAgICBub2RlLnBhcmFtID0gdm9pZCAwO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHNlZ21lbnQgPT09IFwiKipcIikge1xuICAgIGlmIChub2RlLndpbGRjYXJkKSB7XG4gICAgICBfcmVtb3ZlKG5vZGUud2lsZGNhcmQsIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4ICsgMSk7XG4gICAgICBpZiAoX2lzRW1wdHlOb2RlKG5vZGUud2lsZGNhcmQpKSB7XG4gICAgICAgIG5vZGUud2lsZGNhcmQgPSB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjaGlsZE5vZGUgPSBub2RlLnN0YXRpYz8uW3NlZ21lbnRdO1xuICBpZiAoY2hpbGROb2RlKSB7XG4gICAgX3JlbW92ZShjaGlsZE5vZGUsIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4ICsgMSk7XG4gICAgaWYgKF9pc0VtcHR5Tm9kZShjaGlsZE5vZGUpKSB7XG4gICAgICBkZWxldGUgbm9kZS5zdGF0aWNbc2VnbWVudF07XG4gICAgICBpZiAoT2JqZWN0LmtleXMobm9kZS5zdGF0aWMpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBub2RlLnN0YXRpYyA9IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIF9pc0VtcHR5Tm9kZShub2RlKSB7XG4gIHJldHVybiBub2RlLm1ldGhvZHMgPT09IHZvaWQgMCAmJiBub2RlLnN0YXRpYyA9PT0gdm9pZCAwICYmIG5vZGUucGFyYW0gPT09IHZvaWQgMCAmJiBub2RlLndpbGRjYXJkID09PSB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGZpbmRBbGxSb3V0ZXMoY3R4LCBtZXRob2QgPSBcIlwiLCBwYXRoLCBvcHRzKSB7XG4gIGlmIChwYXRoW3BhdGgubGVuZ3RoIC0gMV0gPT09IFwiL1wiKSB7XG4gICAgcGF0aCA9IHBhdGguc2xpY2UoMCwgLTEpO1xuICB9XG4gIGNvbnN0IHNlZ21lbnRzID0gc3BsaXRQYXRoKHBhdGgpO1xuICBjb25zdCBtYXRjaGVzID0gX2ZpbmRBbGwoY3R4LCBjdHgucm9vdCwgbWV0aG9kLCBzZWdtZW50cywgMCk7XG4gIGlmIChvcHRzPy5wYXJhbXMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIG1hdGNoZXM7XG4gIH1cbiAgcmV0dXJuIG1hdGNoZXMubWFwKChtKSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IG0uZGF0YSxcbiAgICAgIHBhcmFtczogbS5wYXJhbXNNYXAgPyBnZXRNYXRjaFBhcmFtcyhzZWdtZW50cywgbS5wYXJhbXNNYXApIDogdm9pZCAwXG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBfZmluZEFsbChjdHgsIG5vZGUsIG1ldGhvZCwgc2VnbWVudHMsIGluZGV4LCBtYXRjaGVzID0gW10pIHtcbiAgY29uc3Qgc2VnbWVudCA9IHNlZ21lbnRzW2luZGV4XTtcbiAgaWYgKG5vZGUud2lsZGNhcmQgJiYgbm9kZS53aWxkY2FyZC5tZXRob2RzKSB7XG4gICAgY29uc3QgbWF0Y2ggPSBub2RlLndpbGRjYXJkLm1ldGhvZHNbbWV0aG9kXSB8fCBub2RlLndpbGRjYXJkLm1ldGhvZHNbXCJcIl07XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICBtYXRjaGVzLnB1c2goLi4ubWF0Y2gpO1xuICAgIH1cbiAgfVxuICBpZiAobm9kZS5wYXJhbSkge1xuICAgIF9maW5kQWxsKGN0eCwgbm9kZS5wYXJhbSwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXggKyAxLCBtYXRjaGVzKTtcbiAgICBpZiAoaW5kZXggPT09IHNlZ21lbnRzLmxlbmd0aCAmJiBub2RlLnBhcmFtLm1ldGhvZHMpIHtcbiAgICAgIGNvbnN0IG1hdGNoID0gbm9kZS5wYXJhbS5tZXRob2RzW21ldGhvZF0gfHwgbm9kZS5wYXJhbS5tZXRob2RzW1wiXCJdO1xuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIG1hdGNoZXMucHVzaCguLi5tYXRjaCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGNvbnN0IHN0YXRpY0NoaWxkID0gbm9kZS5zdGF0aWM/LltzZWdtZW50XTtcbiAgaWYgKHN0YXRpY0NoaWxkKSB7XG4gICAgX2ZpbmRBbGwoY3R4LCBzdGF0aWNDaGlsZCwgbWV0aG9kLCBzZWdtZW50cywgaW5kZXggKyAxLCBtYXRjaGVzKTtcbiAgfVxuICBpZiAoaW5kZXggPT09IHNlZ21lbnRzLmxlbmd0aCAmJiBub2RlLm1ldGhvZHMpIHtcbiAgICBjb25zdCBtYXRjaCA9IG5vZGUubWV0aG9kc1ttZXRob2RdIHx8IG5vZGUubWV0aG9kc1tcIlwiXTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIG1hdGNoZXMucHVzaCguLi5tYXRjaCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXRjaGVzO1xufVxuXG5leHBvcnQgeyBhZGRSb3V0ZSwgY3JlYXRlUm91dGVyLCBmaW5kQWxsUm91dGVzLCBmaW5kUm91dGUsIHJlbW92ZVJvdXRlIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/rou3@0.5.1/node_modules/rou3/dist/index.mjs\n");

/***/ })

};
;